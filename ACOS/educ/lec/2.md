АКОС #2 (09/09/2021)

Data Formats and Files

Текст - всё то, что формально воспринимается человеком (есть байты - им сопоставляем письменное)

не всё печатное - есть семантическое (есть пробелы, дефисы, во многих ЯП /0 - символ конца строки)

В Си/плюсах есть тип char - но это не символ, это 1 байт (когда-то было это достаточно для одного символа, сейчас нет)

Теперь мы можем взять произвольный массив символов, его индексировать (это строка), но символы должны иметь одинарный размер.

Нет единого стандарта, какого размера должен быть wchar_t (16 бит для MSVC, 32 бит для glibc).
Что широкая строка, что обычная строка - в плюсах это просто шаблонная строка

Пример: многострадальный русский язык!

ANSI (7 бит) поддерживает лишь символы английского языка. КОИ-8 (8 бит) имеет +1 бит для замены языка. OEM Encoding имеет поддержку со стороны железа. CP1251 наконец-таки дал возможность для кучи кодировок! Для русского - одни, для западноевропейских - другие... Но для русского тоже было несколько вариантов. В 80-90-х было много файлов в разных кодировках, теперь сошлись к Unicode (наконец-то!!!)

Кодировки не особо совместимы между собой. Например, у нас есть текст "Слава строителям коммунизма!" в UTF-8. Переведём его в CP1251, получим крякозябры. На https://habr.com/ru/post/147843/ подробно про это написано.

UTF-8 - кодировка, сопоставляющая каждому символу переменное количество байт в зависимости от того, что это за символ.

До 2003 были модификации с 5-6 байтами, но потом выяснилось, что это too much, а 4 байта в самый раз. Теперь даже эмоджи есть! И даже старенькие и простенькие программы умеют честно их вывести! 

stat - отображает метаинформацию по файлу.

Как интепретируется текст? Смотрим старшие биты, смотрим, закончились ли. 

Есть так называемые Control Chararcters.

\n - new line
\r\n - Windows-style new line, also in HTTP
\f - form feed
\t - horizontal tab
\v - vertical tab
\b - backspace
\e - prefix for terminal control sequence

Высокоуровневые функции обычно проделывают аналитическое преобразование "\r\n".

Exercise! Как с помощью \r посчитать кол-во строк?

В Линуксе есть МОРЕ команд, семантика которых унаследовала древние UNIX-команды, в частности предназначенные для работы с текстом.

cat - для текстов с бинарниками
wc - сколько байт, символов, строк в тексте
head, tail - берём части текста
iconv
grep - регулярки

Переменные окружения... Начинаются на LC_, они имеют разный приоритет...
Пример: LC_MESSAGES=uk_UA.UTF-8 (поменяем на украинскую мову)

Географический факт! Хотите говорить на английском, но юзать метрическую систему? Welcome to Canada!
Общий вид! lang_COUNTRY.ENCODING

А теперь про регулярные выражения!

? - любой символ
* - неотрицательное кол-во символов

There are some examples!

echo *.c - shows all files with extension .c

echo "*.c" - shows *.c

POSIX: . - любой символ, [...] - объединяем символы in range, ^, $ - начало и конец строки, (...) - подгруппа.

Экранировать можем с помощью \

Расширяем POSIX: {n} - n раз повторяем предыдущий символ (их группу), + - повторение строго 1/более раз

Даёшь гендерно-нейтральные выражения! sed -E 's/(mom|dad) /parent ' file.txt


Теперь поговорим про бинарники! Мы не сможем просто так посмотреть их просто так, зато они занимают меньше места, но они непортируемы..

reset - сбрасывает терминал до начального значения

hexdump - выводит файл в виде некоторой последовательности байт (Виктор Вадимович не рекомендует!)

xxd - умеет без мусора выводить представление бинарного файла

Как читать? Справа налево или слева направо? В многих процессах принят Little-Endian (a. k. a остроконечный) - справа налево

в risc-процессорах использовался Big-Endian (тупоконечный) - слева направо

Названия не особо осмысленные - они исходят из Гулливера Дж. Свифта. Американцам юмор зашёл.

xxd умеет делать бинарник по вашему усмотрению! Как вы зададите 16-ричное представление, так и будет!

Для бинарников символы \0 не являются значными! Это принципиальное отличие от текстовых файлов

base64 - некоторое подмножество текстов, содержащее лишь латиницу, не учитываются даже скобки!

openssl есть даже на маках, универсальная штука

Бывает, нужно сжимать данные... Есть gzip, gunzip или gzip -d.

Как работать со сжатыми данными? zcat, zgrep, zless, zcmp, zdiff и компания идут вам на помощь!

gz староват... Есть bz2, xz... bzcat и другие тоже помогут вам обращаться с файлами!

zip поддерживает юникод с 2006 года... но zip не поддерживает атрибуты файлы...

rar не прижился, потому что не open source, а фаны Линукса не любят не опенсорсное...

./configure - обычный shell скрипт, задача которого проверить наличие файлов, библиотек, узнать, что там за компилятор

Пакет - по сути сжатый архив, содержащий дополнительную информацию, какие файлы содержатся и общие сведения.

Всего два формата: dpkg, rpm
