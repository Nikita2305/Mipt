АКОС №6. Кэш и SIMD.

Остановились в прошлый раз на различиях между RISC и CISC.

RISC более подходящая для телефонов, это более экономная штука.

Фаны RISC: ARM, AArch64, Atmel AVR, MIPS, IBM PowerPC, SPARC...

CISC: x86, x86-64, Zilog Z80, Motorola 68K, Itainum и, внимание, наш отечественный Эльбрус!!!

Кто у нас производит процессоры? Например, есть компании, которые имеют производство полного цикла: Intel, AMD. Есть так называемые fabless компании, которые не имеют собственной производственной базы, но умеют очень хорошо чертить микропроцессоры. Например, это Mediatek, Quallcomm, Apple, Samsung, многие-многие другие. Есть те, кто лицензирует, например, Broadcom, Loongson, NIISI RAS, ну и есть фаны опен-сорса: SiFive, Mikron.

x86 - не самая удачная архитектура, не самая удобная. Плюс ещё сложно проверить отсутствие так называемым секретных блоков (а это важная информация для инфобеза!).

Можно производить хоть в России, но дешевле в Тайване. Ну а если нам запретят размещать заказы, то нам конец... Китайцев это уже коснулось (Huawei).

Как развивались языки программирования? Сначала в 1967 появился BCPL от М. Ричардса, затем язык B в 1969, затем творение Д. Ритчи - язык Си - 1972. Один товарищ Страуструп подумал добавить классы, это выродилось в 1985, потом фан метапрограммирования Александреску придумал язык D на пару с Брайтом в 2001 году (впрочем, он так и не стал особо популярным).

LLVM - некоторый "фреймворк" для создания компиляторов, с точки зрения реализации отвратительный, как сказал господин Яковлев. С одной стороны, это набор компиляторов (это может быть C, C++, Rust, Swift, Objective-C), а с другой стороны кое-что бекендовское...

Есть ещё одно творение, называется Java Bytecode. Можно запускать везде, где есть джава-машина. Это просто автомат с магазинной памятью, читающий выражения и т. д. Её просто реализовать.

Где же наконец пригодится ассемблер? Для взаимодействия с железом, портами ввода/вывода, выполнения системных вызовов. В языках типа плюсов нет встроенных универсальных инструментов не это. А ещё есть ассемблерные вставки с использованием векторных инструкций.

Векторные инструкции - 128-битные. Есть 128-битные регистры XMM0, ..., XMM15. Если вертикальные и горизонтальные операции (из векторные в скалярные, например, минимум/максимум).

MMX - XMM регистры, только целые числа
SSE - XMM регистры, числа с плавающей точкой
AVX - YMM регистры (256 бит)
AVX-512 - ZMM регистры (512 бит)

Но векторные инструкции встречаются не только в мире x86! Есть ARM Neon (Cortex-A), ARM Helium (Cortex-M), RISC-V (нет стандарта)...

Есть ещё OpenMP, позволяющий писать обычные программы с циклами, с прагмами и т. д...

Внимание фанатам линала! Специально для вас BLAS!

Есть два типа памяти: статическая (SRAM) и динамическая (DRAM). Для SRAM на чтение нужен 1 такт, для записи уже нужны 2 такта. Она плоха тем, что жрёт много энергии. DRAM позволяет размещать много памяти, но доступ уже помедленнее.

Уровни кеша: L1, L2, L3. L1 (для Интела index0 + index1) - быстродоступные инструкции, кеш данных.

Характеристики кеша: уровень кеша (level, 0-2), размер кеша (32 КБ - 35 МБайт), тип кеша, количество ядер
