Минимальные остовы

Опр. G = (V, E) - граф.
    Граф H in G - остовный подграф G, если H.V = G.V.
    Граф T in G - остовное дерево(или остов), если T - дерево и остовный подграф G.

*Тут был пример остова*

Наша ближайшая цель:
    Если G - взвеш. неориент. граф.,
        то найти остов минимального веса.

Лемма (о безопасном ребре / о разрезе). Ключевая лемма.
Формулировка:
Пусть уже выбраны некоторые рёбра в мин. остов (причём, кажется, это связное множество - т.е. дерево)
(т.е. утв-ся что мин остов существует как надмножество эти рёбер)
Тогда рассмотрим самое дешёвое ребро, торчащее из нашего дерева во "внешность".

Более формально:    
    Пусть С - связный подграф-дерево, в то же время подмножество мин.остова.
    Пусть е - самое дешёвое ребро между C и G\C.
    Тогда С+e - также подмножество min остова.

Док-во:
    Пусть T - мин остов содержащий С.
    Если e in T, то и доказывать нечего.
    Иначе - e not in T. Сконструируем T'.
        Пусть e соед u <-> v.
        Рассмотрим путь в дереве T между u и v.
        В этом пути существует по крайней мере одно ребро, пересекающее разрез.
        Удалим его и вставим наше e. Очевидно связность не нарушится, а значит победа.
        Вес T' <= Вес T -> T - мин. остов.

 
Алгоритм Прима.
Интуиция - будем по очереди добавлять мин. рёбра в соответствии с Леммой. n-1 итерация.
Корректность обосновывается непоср. Леммой.
Асимптотика и реализация:
1) O(n*m) - n раз пройдём по всем рёбрам и выберем минимальное подходящее.
2) O(n*n + m) - для каждой вершины не из C будем поддерживать d[v] - ребро минимального веса идущее в С.
    тогда чтобы найти нужное ребро на i-й итерации - пройдём за O(n) по всем вершинам не из С
        и найдём min(d[v]). Таким образом мы добавили ребро и вершину q вместе с ним в С.
    также чтобы обновить ответ - найдём все вершины-соседи q, идущие в not C.
        В них нужно обновить значение d[v].
3) O(m * logn)
    n раз extractMin
    m раз decreaseKey
    // O(m + nlogn) - Фиб. куча.

Замечание: Чтобы поддерживать минимальное ребро - будем для каждой вершины из G\C поддерживать
минимальное допустимое

Следствие из леммы о безопасном ребре(обобщение)
        Теперь С - не обяз. связный граф. Лемма продолжает работать.
Более формально:
    Если H - подмн-во min остова, e - самое дешёвое ребро, соед. разн. комп. связности H.
    Тогда H+e - также подмн-во min остова.
Док-во: Напрямую следует из Леммы о без. ребре, положив C - одну из компонент, кот. e соед.
    Тогда всилу того, что e - минимальное по всем компонентам, то он минимальное между C and (not C)
    // *Что-то на умном*, 


Алгоритм Крускала. (Kruskal)
Отсортируем рёбра в порядке возрастания весов.
В этом порядке добавляем очередное ребро в T, если оно соед. разные компоненты.
Корректность непоср. следует из (Следствия из Леммы).
Асимптотика:
    Сортировка - O(mlogm), но в исключительных случаях можно и быстрее, так что иногда это быстрее O(m logn)
    Добавление рёбер и т.п. реализуется с помощью (СНМ - сист. непересек. мн-в.)
        - Узнать, в каком-мн-ве лежит u
        - Объединить два мн-ва

Реализация СНМ.
    Каждое мн-во будем хранить как дерево. Корень дерева назовём лидером. Мн-во будем ассоциировать с его лидером.
    Чтобы хранить их как деревья, будем хранить: forall(v): p[v] - родитель v.
    Для лидеров p[v] = v или -1, например.
    Чтобы узнать в каком мн-ве лежит вершина - поднимемся по дереву и вернём лидера.
    Чтобы объединить мн-ва - подвесим одного лидера к другому.
Придумаем как сделать, чтобы высота дерева(а это и есть асимптотика каждой операции и пока что O(n))
    была поменьше.

Эвристика по рангу (O(logn)).
    size[l] - число вершин в мн-ве с лидером l.
    Будем подвешивать лидера с меньшим size к лидеру с большим size и увеличивать размер последнего.
    Утв. Высота дерева теперь O(log(size)). Пусть мы в листе. Каждый подъём увеличивает размер поддерева в >=2 раза
        А значит высота log(size)

Эвристика сжатия путей.
    Предложение: структура дерева неважна. Можем переподвешивать вершинки напрямую к лидеру
    Реализация get_lider(v) {
        if(p[v] == -1) //its lider
            return v
        else
            return p[v] = get_lider(p[v]);
    }

Утверждается, что объединяя эти эвристики - получится ~O(1) // Комментарий автора: очень-очень-очень быстро
Пусть A(m,n) = {n + 1, [if m = 0] ||| A(m - 1, 1), [if m > 0, n = 0] ||| A(m - 1, A(m, n - 1)), [if m, n > 0]}
Пусть alpha(k) = min{n > 0 | A(n,n) >= k} // в некотором смысле обратная
Более формально - комбинация двух эвристик даст асимптотику ответа на запрос: O(alpha(size))
    Причём A(4,4) = 2^(2^65536) - 3.
        //Интересный факт: A(4,4) = 2^(2^(2^(2^(2^2)))) - 3
    Тогда alpha(x) <= 4 для используемых нами чисел.
// Без док-ва.

Упражнение:
    Если оставить только эвристику сжатия путей, то ответ на запрос: O*(logn)
        //Подсказка-пример на О* - если объединяли unite(i, i+1) // так, чтобы был бамбук. А потом спросили get(1).
            Будем O(n) хотя бы на 1 get.

Итоговая асимптотика на работу Крускала: O(mlogm + m*alpha(n))


Алгоритм Борувки.
    Для каждой вершины найдём самое дешёвое ребро(возможно некоторые рёбра будут выделены дважды).
        Сжимаем выделенные компоненты и запуститься рекурсивно.
    Замечание: следует выбирать мин. рёбра аккуратно(например ребро, кот. ведет в вершину с миимальным номером)
        Зачем? Пример. Рёбра: (from, to, cost): (1,2,1), (2,3,1), (3,1,1) - можно случайно выбрать все рёбра
        И получить даже не остов.
    Асимптотика: O(log(n) * m) // logn итераций, O(m) на обработку на каждом шаге(m > n), чтобы был остов.
    
Док-во:
    Предложение: давайте мысленно ориентируем рёбра те, которые будем выбирать в алгоритме Борувки на очеред. итер.
    Утверждение - получим функциональный граф(когда из каждой вершины выходит одно ориент. ребро), который
        выглядит как 1 ориент. цикл и деревья, подвешенные к нему.
    Если длина цикла > 2, то 1) заметим длины рёбер равны(a1.len >= a2.len >= ... >= a1.len)
                            2) заметим что номера(всилу разных номеров) v1 < .. < vn < v1
        противоречие.
    Значит длина цикла 2(если 1, то из этой вершины в цикле не исходит ни одного ребра). 
        Ну тогда имеем достаточно понятную структуру функ. графа(по факту в нём ориентированно лежат те рёбра
        которые хотим добавить на очередной итерации алгоритма Борувки):
            Ребро, к концам которого приделано по дереву
        А значит циклов в остов не добавим.
    
    Замечание: В нынешнем виде Лемма о безоп. ребре разрешает добавлять по 1 ребру, а мы хотим добавить целый граф.
    Будем рассматривать рёбра в порядке подъёма по деревьям в функ. графе снизу вверх.
    Когда рассматриваем листовое ребро - замечаем, что добавление ОК
// Формализовать в голову.    
