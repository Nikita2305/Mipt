A* - практическое приложение.
В наших алгоритмах ранее вершина тем раньше была обработана,
чем меньше real_dist от неё до s.
Однако, на самом деле, давайте теперь будем оценивать g[v] + h[v] - где
    g[v] - текущее кратчайшее расстояние от s до v.
    h[v] - нижняя оценка на расстояние от v до f.
A* работает как Дейкстра на f[v] = g[v] + h[v]
h[v] - называется эвристика.
    Например если h[v] = 0, то А* вырождается в алгоритм Дейкстры.
    
    Чем более точную оценку будем давать на h[v] - тем лучше.
    
    Если h[v] = dist(v, f), то А* - рассматривает почти только опт. путь.
    Т.е. мы будем последовательно рассматривать вершины кратчайшего пути(пример с s и f, соед. кучей путей)
    
    Если h[v] может быть > dist(v,t), то А* не обязательно находит кратчайший путь, но может довольно быстро
    найти некоторое его приближение. (Б/д)

Опр. Эвристка h - допустимая, если для любой v: h(v) <= dist(v,t) // admissible
Зам. h(f) = 0
Опр. Эвристика h - монотонна,  //consistent?
если h(f) = 0 и для любого (u, v): h(u) <= h(v) + cost(u, v) // Не забываем что это расстояния до f.
УТВ: Монотонная эвристика является допустима.
    // Доказательство простое и оставлено читателю

Результаты:
    1) Если h - монотонна, то А* гарантированно находит правильный ответ и раскрывает каждую вершину
        не более чем один раз
    2) Если h - допустимая, то А* гарантированно находит правильный ответ, но раскрывает каждую вершину
        не обяз. <= 1 раза
    3) Если h - недопустимая, то А* не гарантированно находит правильный ответ

Доказательство(1):
УТВ: h - монотонная -> последовательость f(a_n) неубывает, где a_n - последовательность вытаскиваемых элементов
   Д-во: Пусть извлекаем v и хотим обновить g(to) [иначе f(to) не изменится и вообще ничего не изм.]
        1) g(to) = g(v) + cost(v, to)
        2) h(v) <= h(to) + cost(v, to) // монот.
            т.е.  h(to) >= h(v) - cost(v, to)
        Складывая 1) и 2): f(to) >= f(v)
        Т.е. никогда не положим в кучу меньше, чем "заметающая прямая", а значит УТВ верно.
Сл-е: Каждая вершина раскроется 1 раз.(вообще эти факты эквивалентны, имхо)

Продолжение док-ва(1): Хотим доказать, что f(fin) - действительно длина кратчайшего расстояния.
    Ну пусть существует путь длины OPT, для него бы f(fin)[btw f(fin) = g(fin)] обновилось через OPT (ранее),
    т.к. мы в некотором смысле рассматриваем все пути из start в fin.

Зам. Если h(v) = dist(v, t) -> h - монотонная(из нер-ва треугольника по dist).
    Ну тогда соотв. замечание на ~13 строке в нек. смысле подтверждается

Примеры.
1) На сетке с препятствиями. (ходим горизонт/вертикально)
    h(v) = |v.x - f.x| + |v.y - f.y|
2) На сетке с препятствиями и диаг. ходами
    h(v) = max(|v.x - f.x|, |v.y - f.y|)
3) h(v) = sqrt((v.x - f.x)^2 + (v.y - f.y)^2)

Реализация: совершенно аналогично алгоритму Дейкстры(не забудем остановиться, когда вытащим из кучи finish)
Асимтотически: m + nlogn (в случае Фибб, напр.)

Вывод: получится неасимптотическая оптимизация на практике

Алгоритм Флойда.
Ищет попарные кратчайшие расстояния.
МОГУТ быть отрицательные рёбра, но НЕТ отриц. циклов.

dp[i][j][k] - минимальная длина пути i->j, т.ч. все промежуточные вершины имеют номера <= k.
База:
dp[i][j][0] = cost(i, j) / +inf, если нет ребра
Переход(Порядок - think, Ans: легко видеть - главное измерение: k): 
dp[i][j][k] = min(dp[i][j][k - 1], dp[i][k][k - 1] + dp[k][j][k - 1])
Ans: dp[s][f][n]
Асимптотика: O(n^3) по времени и памяти

Реализация:
    g - матрица смежн. графа. g[i][j] = вес ребра / + inf
    for (k = 1 .. n)
        for (i = 1 .. n)
            for (j = 1 .. n)
                g[i][j] = min(g[i][j], g[i][k] + g[k][j])
    Т.е. поочереди добавляем вершины k = 1 .. n и полагаем, что путь может проходить через них

Утв:
    cost(i,j) <= g[i][j] <= dp[i][j][k] после k-й итерации внеш. цикла
    Док-ся по индукции в силу похожести переходов dp и g

Восстановление ответа: p[i][j] = k, если обновили g[i][j] через i->k->j
// Рекурсивная функция, например


Алгоритм Форда-Беллмана
Цель - кратчайшее расстоние от s до всех, но могут быть отрицательные циклы
УТВ(очев): 
    dist(u, v) = -inf <=> сущ. отриц. цикл C, т.ч. u -> C -> v
    Док-во оставлено на рассмотрение читателю(1:04:00).

dp[v][k] - кратч. расстояние от s до v, при использовании <= k рёбер.
База: dp[v][0] = (0 if v == s else +inf)
Переход:
    dp[u][k] = min(dp[u][k - 1], min{dp[v][k] + cost(v, u) | for (v, u) in edges})
Ответы(в предположении, что нет отриц. циклов): for v: dp[v][k - 1]

Асимптотика: O(n * m)

Отр. циклы.
Найдём dp[v][n] по тому же алгоритму.
Утв. Пусть С - отриц. цикл, достижимый из s.
    Тогда найдётся хотя бы одна вершина этого цикла, что dp[v][n] < dp[v][n - 1]
Док-во:
    Рассмотрим цикл С и веса рёбер c1..ck, Summ(c1..ck) < 0
    Поступим от противного, т.е. dp[v][n] = dp[v][n-1], forall(v in C)
    Тогда dp[v_i+1][n] <= dp[v_i][n-1] + ci
    Складывая такие неравенства по всем рёбрам из цикла, тогда
    Summ(c1..ck) >= 0 - противоречие

Мораль: за O(n*m) можно найти хотя бы по 1 вершине на каждом отриц. цикле.
    Любая вершина, достижимая из таких: dist = -inf.
    иначе dist[v] = dp[v][n-1]
