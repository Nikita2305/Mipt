Кратчайшие пути в графах.(1)
Опр. Если G = (V, E) - невзвеш. граф, то dist(u, v) - min число рёбер на пути от u до v.
dist(u, v) = +inf, если нет пути u->v

Опр. G = (V, E, w), где w: E->R, весовая функция - взвеш. граф.
Тогда во взвеш. графе dist(u, v) - min сумма весов рёбер на пути от u до v. 

BFS - breadth first search. Поиск в ширину.
Находит кратчайшие расстояния от s до всех вершин в невзв. графе.
// q - queue, НО: просто думать об этом как о векторе, в который мы пушбэчим и сдвигаем указатель, начиная с i = 0
// Тогда будем говорить, что штука обработана, если она лежит левее указателя
Док-во.
    Утв. 1) Пусть dist[q.front()] == k; Тогда dist[q] = k,k...,k,k+1,...,k+1
        2) Более того к этому моменту любая v(dist[v]) <= k: лежит в q или уже обработана
        3) Если алгоритм выполнил в нек. момент присваивание dist[v] = k, то это и есть правильный ответ.
    Докажем по индукции.
        База:
            1) q = {s}. dist[s] = 0
            3) dist[s] = 0 действительно верный ответ
            2) Любая вершина с dist[v] = 0 это v = s, которая лежит в q.
        Переход:
        Пусть в некоторый момент:
            1) dist[q] = k,k...,k,k+1,...,k+1
            Тогда после q.pop_front() в q добавятся только вершины,
                    для которых ответ не определён и который соединены с q.front() [обозначим их за to] 
            dist[to] = k+1
            3) real_dist[to] <= k + 1, очев.
                Пусть real_dist[to] <= k. Но это противоречит тому, что to уже лежит в q или обработана.
                // т.к. to на самом деле только что была необработана.
                отсюда real_dist[to] = k + 1 = dist[to]
            2) Если v - не первая найденная вершина с dist[v] = k, тогда по предп. инд-ии для пред. итерации,
                любая вершина с dist[u] = k, уже лежит в q или обработана
            Если v - первая найденная вершина с dist[v] = k.
                Докажем, что в очереди сейчас уже лежат все u: dist[u] = k
                Ну пусть не лежит t: dist[t] = k
                Но тогда dist[t.prev] = k - 1, но t.prev мы уже обработали, а значит и t должны были доб. в очередь
// Во время подготовки к Алгосам - разграничить real_dist и dist
    
Асимптотика O(n + m)

0-k BFS. Пусть наша весовая функция w: E -> {0...k}
(Альтернативное решение, чуть медленнее - O(kn+km), но решение: расчленим все пути на невзвеш. рёбра и победим).
Для каждого возможного расстояния (0..kn) создам очередь.
Далее буду Очереди по очереди обрабатывать и для каждой Очереди запускать подобие бфс.
Асимптотика O(kn + m)
Упражнение: можно обойтись k + 1 очередью(очев).
Док-во:
    Докажем что после обработки i-й очереди - ВСЕ вершины с расстоянием <=i будут найдены(ответ будет верен).
        И только они. Докажем по индукции.
    База:
        Добавив s в q[0], а затем запустив bfs по этой очереди, в q[0] добавятся только вершины, достижимые по 
        рёбрам длины 0. Очевидно это совпадает с множеством {v: real_dist[v] = 0}
    Переход:
        Пусть были верно найдены ВСЕ dist[v], {v: real_dist[v] < k}.
        Рассмотрим очередь k. Там лежат все вершины, достижимые из множества обработанных вершин за 1 ребро.
        Для них real_dist[v] = k(Он по крайней мере такой, но точно не меньше, иначе v обработана).
        * Пусть после обработки k-очереди какая-то вершина v(real_dist[v] == k) не найдена
        Тогда рассмотрим v.prev. real_dist[v.prev] < k. or == k.
            В первом случае мы бы добавили v в q[k] в момент обработки v.prev
            Во втором случае продолжим спускаться по v.prev.prev, пока не обнаружим, что в какой-то момент
            dist[v.prev....prev] < k. Но она-то была обработана, а значит и были обработаны все v.prev...
            В том числе и v была обработана
        * Пусть после обработки k-й очереди какая-то вершина v(real_dist[v] > k) была обработана.
            Ну этого очевидно быть не могло, т.к. мы на каждом шаге верно считаем dist[v], а значит положили бы
            вершину v в очередь попозже
// Во время подготовки к Алгосам - формализовать 

Двусторонний BFS.
Ищем dist(s,t) для заданных s,t.
От s идём в одном порядке, от t идём по revGraph. с помощью стандартного dfs.
Утв. Первая вершина посещённая с двух сторон - искомая точка.
Редко работает, но если слои растут как a^k для фикс a, то это улучшает в корень раз относительно BFS.

Алгоритм Дейкстры - работаем на положительных графах
Замечание: 0-k BFS работает также
Асимптотика(дефолт куча - set): O((m + n) * log(n)) //m logn - update dist, n logn - extract min
!!!Используя Фибб. Кучу можно - O(m + nlogn), т.к. extractMin - logn, decreaseKey - O(1)
Док-во корректности:
    УТВ. Если вершина v - раскрывается, то dist[v] в тот момент - это верный для неё дистанс.
    Рассмотрим первый момент, когда это не выполнится (для v).
    // В каждый момент dist[v] >= real_dist[v], т.к. в dist[v] всегда какой-то путь или +inf 
    Т.е. dist[v] > real_dist[v].
        Рассмотрим real_path(v) в этот момент.
        Он сначала ходит по обработанной компоненте, а затем прыгает в необр. компоненту.
            1) Он сразу прыгает в v. Но тогда dist[v] = real_dist[v], т.к. мы по последн. ребру обновили когда-то
                dist[v]
            2) Он сначала прыгает в u, а затем приходит в v.
                dist[u] >= dist[v], т.к. мы брали по алгоритму вершину с минимальным расстоянием.
                real_dist[u] = dist[u], по рассуждениям из (1)
            В обоих случаях видим противоречие с нерав-вом dist[v] > real_dist[v]
                
// Во время подготовки к Алгосам - формализовать. В этот момент мне нравится идея с увеличением верной компоненты

Двусторонний алгоритм Дейкстры
Идея аналогичная двустороннему BFS - запуск Дейкстр из обеих вершин.
Остановимся, когда какая-либо вершина будет обработана в обоих частях.
Как получить ответ? Мы имеем два мн-ва обр. вершин, которые почти не пересекаются
Тогда ответ ans = min {u in S1, v in S2: dist(s, u) + cost(u, v) + dist(v, u)}
Интересно, что dist(s, u) - не обязательно кратчайшее расстояние (s ... u)
Почему достаточно перебрать такие рёбра (u, v)?
Мы очевидно перебрали не все такие пути, но какие ещё есть, а вот какие: содержат какую-то вершину вне S1, S2
Тогда dist(s, x) + dist(x, f) >= dist(s, mid) + dist(mid, f), а значит такие пути можно не рассматривать
