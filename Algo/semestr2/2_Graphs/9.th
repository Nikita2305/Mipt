Техника масштабирования.
Пусть С - верхнее ограничение на все пропуснкные способности c(u, v).

Предложение:
Итерация под номером K: (K убывает, т.е. сначала рассматриваем сначала большие рёбра, потом добавляем к ним поменьше)
Рассмотрим сеть с рёбрами, для которых c(e) >= 2^k (т.е. добавили некоторые рёбра относительно прошлого шага)
И теперь протолкнём поток вдоль новых образовавшихся путей. 

Замечание:
В момент итерации под номером 0 получим просто дефолт Э.К. и он в любом случае протолкнёт всё что нужно, обеспечивая корректность.

Утверждение:
На каждом итерации мы проталкиваем поток вдоль О(E) путей, таким образом асимптотика O(logC * E * E) // лишняя Ешка из-за самого проталкивания

// Что-то про округление?

Докажем его.
Пусть после k-го шага суммарно пущено F_k потока, тогда F <= F_k + 2^k * E
Почему? Ну потому что величина остаточного потока |f| <= c(S, T) <= 2^k * E // поток основанный на недобавленных рёбрах
    // где S - вершины достижимые из s, T - не достижимые в остаточной сети.
        (S, T) - разрез, т.к. t не достижима т.к. F_k - максимальный поток и в остаточной сети нет пути s -> t.
        c(S, T) <= 2^k * E, т.к. это у каждого ребра остаточная капасити <2^k.
Отсюда следует, что на (k - 1) шаге можно найти <= 2 * E. Потому что cap >= 2^(k-1) и добавить потока можно максимум 2^k * E, то
    путей <= 2 * E, ибо каждый путь даёт вклад 2^(k-1).

Утверждение доказано.

Замечание: можно использовать и Форда-Фалкерсона, асимптотика не изменится - О(E^2 * logC)


Алгоритм Диница. (Ефим Диниц)

Опр. Пусть (G,s,t,c) - сеть,
Слоистая сеть, построенная по G: Vi = {u: dist_bfs(s,u) = i}
Оставляем рёбра только слева направо. (Игнорируем также и рёюра внутри компонент)
Рёбра есть только между соседними, т.к. если ребро (u, v) делает перескок, то значит кр. расстояние до v - меньше

Замечание. Алгоритм ЭК на самом деле по итогу находит путь из Слоистой сети, т.к. проталкивает вдоль кратч.

Опр. Пусть G - слоистая сеть. Тогда блокирующий поток в ней - это такой поток, который нельзя увеличить без введения обратных рёбер.

Пример - ромб с диагональным ребром, как обычно. Путь AB - BD - DC --- блокирующий.

Алгоритм Диница:
- Пока не найден макс поток { // т.е. пока есть путь из s в t
    Построй слоистую сеть (обратные рёбра мы всё-таки используем как обычный путь, вдоль которого можно протолкнуть)
    Найди в ней блокирующий поток 
}

Замечание: Поскольку алгоритм останавливается ровно в момент отсутсвия пути s->t, то по Т.Форда-Фалк. он корректен.

Пояснение1: слоистая сеть строится просто запуском БФС

Пояснение2: 
А как искать блок. поток? 
Пусть ptr[v] = номер первого интересного ребра, исходящего из v.

int dfs(int v, int flow) { //flow - min c(u,v) на пути s ... v, чтобы понять,какой maxflow можем протолкнуть сейчас
    if (v == t) return flow;
    while (ptr[v] != g[v].size()) {
        Edge e = g[v][ptr[v]] // ребро
        if (level[v] + 1 != level[e.to]) { // Чтобы рассматривать рёбра только из слоистой сети
            ++ptr[v]; continue;
        }
        if (e.cap == e.flow) { // если ребра нет в ост. сети, то его игнорируем // техническое
            ++ptr[v]; continue;
        }
        int x = dfs(e.to, min(flow, e.cap - e.flow));
        if (x > 0) {
            e.flow += x;
            e.reversed.flow -= x; //будем все рёбра хранить в списке, обратные рёбра - рядом, чтобы (e xor 1) юзать
            return x;
        }
        ++ptr[v];
    }
    return 0;
}

Утверждение: этот алгоритм работает за O(V + E) // поиск. блок. потока

Алгоритм Д:
while (true) {    
    bfs() // слоистая сеть
    if (s -/-> t) 
        break
    while (dfs(s, inf) > 0) {} 
}

Утверждение: Если в dfs(s, inf) все ptr суммарно увеличились на k, то время работы этого dfs O(V + k)
k - количество холостых запусков, V - макс. длина пути, вдоль которого протолкнули

Одна итерация Алгоритма Диница:
    O(V * (кол-во найденных путей) + (сумма изм. всех указателей)) <= O(V*E + E) = O(V * E)

Утверждение: Всего итераций O(V), т.к. после каждой итерации dist'(s, t) > dist(s, t)
Т.е. после проталкивания блокирующего потока в остаточной сети: dist(s, t) увеличивается.
    После пропускания блок. потока могут появиться ьолько рёбра Vi -> Vi-1.
    Кратчайший путь не может уменьшиться.
    Может ли он остаться таким же? Нет, т.к. то был блокирующий поток и он блокирует все прямые пути в слоист. сети
Ну а значит, as dist(s, t) не может расти дальше V, то и итераций O(V)

А значит асимптотика: _O_(V^2 * E)
Попытаемся улучшить в некоторых случаях.

Опр. forall v != s, t
Cin(v) = Sum(c(u,v) | u in V)
Cout(v) = Sum(c(v,u) | u in V)
p(v) = min(Cin(v), Cout(v))
P = Sum(p(v) | v in V) - ПОТЕНЦИАЛ СЕТИ

Теорема1 (Карзанова):
Число итераций Диница = O(sqrt(p))

Теорема2 (Карзанова) (б/д):
Число итераций Диница = O(C^(1/3) * V^(2/3))

Лемма: Пусть l = dist(s, t), F - maxflow, тогда l <= p / F + 1
Док-во: 
Рассмотрим Vi - iй слой слоистой сети.
Pi = Sum(p(v) | v in Vi)
F <= Pi -----> (l-1)*F <= P1 + ... + P(l-1) <= P
Откуда следует нужное неравенство.

Лемма: P не изменяется при проталкиваниях потока при переходе к остаточной сети.
Д-во: 
Пусть пустили некоторый поток вдоль пути. Рассмотрим u != s, t на этом пути:
s - ... - w - u - v - ... - t
Имеем
Cf(u,v) -= f;
Cf(u,w) += f
p(u) не изменился, а значит P не изменился.

Док-во Теор1:
Сделаем sqrt(p) операций в алг. Диница.
l_new >= sqrt(p) // l = dist(s, t), оно увеличивается на хотя бы 1 каждую итерацию 
По Лемме sqrt(p) <= P / Fост + 1, откуда Fост <= p / (sqrt(p) - 1) , т.е. O(sqrt(p))
А значит потока осталось sqrt(p) и путей осталось не более sqrt(p), и итераций тоже осталось sqrt(p).


Применим Т1 к единичным сетям.

Опр. Единичная сеть: c = 0 or 1.

Замечание1: В единичной сети P = O(E)
p(v) = min(deg_in(v), deg_out(v)) <= deg_in(v) + deg_out(v) 
P <= Sum(deg_in(v) | v in V) + Sum(deg_out(v) | v in V) = 2E = O(E)

Заметим число итераций тогда будет O(sqrt(E))

Замечание2: В единичной сети итерация алг. Диница = O(E)
За все dfs-ы каждое ребро рассмотрится максимум 1 раз.
Т.е. либо оно не подходит
Либо подходит, а значит max(c(e1), ..., c(e2)) = 1 и мы насытим сразу все рёбра и больше не будем их рассматривать

Итоговая асимптотика: O(E * sqrt(E))


Алгоритм Хопкрофта-Карпа.
Поиск max парсоч. в двуд. графе. - Сведём эту задачу к поиску максимального потока.
Введём s и t - фиктивные вершины (s левее двудольного, t - правее)
из s направим рёбра в левую долю, из правой доли направим рёбра в t. Ориентируем рёбра двуд. графа также направо.
Веса всех рёбер сделаем 1.

Асимптотика: 
С одной стороны единичная сеть и Ура O(E sqrtE).
Но можно лучше, ибо P = V, т.к. в левой доле deg_in = 1, в правой deg_out = 1
а значит p(v) <= 1.
Откуда O(E * sqrt(V))

Корректность: Max Flow = Max Matching.
Как устроен поток в этой сети?
Это набор непересекающихся путей вида s -> l -> r -> t
Они не пересекаются в l - очев. Если они пересекаются в r, то as deg_out = 1, то противоречие.
