Деревья(2)

Алгоритм Фарах-Колтона и Бендера
Позволяет решать LCA за O(n) предподдсчёта + О(1) на запрос
По сути мы свели LCA к RMQ на прошлой паре, где соседние числа в массиве отличаются на +-1 (высоты отлич на +-1)

План:
Пусть есть массив длины n
Фикс. k = 1/2 log n и разобъём массив на блоки по k.
Опр. Нормализованный блок - блок длины k, который начинается с 0.
Замечание: всего существует различных нормализованных блоков 2^(k-1) = O(sqrt(n))

Кодируем каждый нормализованный блок int-ом. При n = 1e6 => k = 1/2logn = 10. (2^10 < MAX_INT)
Для всех возможных блоков найдём минимумы на всех префиксах и всех суффиксах и запомним эту инфоррмацию.
O(sqrt(n) * k) = O(sqrt(n) * logn)

Вернёмся к задаче.
Замечание: чтобы получить из произвольного блока - нормализованный - нужно вычесть на нём минимум.
    Мы будем сопоставлять нашим блокам из массива - нормализованные.
При получении запроса l,r имеем несколько полных блоков, один суффикс и один префикс.
Далее строим спарстэйбл на n/k эл-ах, где вместо блока пишем минимум на нём.
О(n/k * log(n/k)) = O(n)

Теперь можно отвечать на запрос за О(1)
Пусть наш l,r упал в L,L+1,...,R-1,R блоки, где L,R заполнены не полностью (суффикс и префикс)
Тогда по номеру L получим mask нормализованного блока, а на нём узнаем ответ на нужном суффиксе 
    и прибавим min обратно.
Для R аналогично, а на L+1,...,R-1 просто воспользуемся нашими Sparse-Table.
Такчто O(1 + 1 + 1) = O(1)

Замечание - 1/2 logn - критично, чтобы получилось O(sqrt(n)) запросов.


Теперь научимся решать обычный RMQ за О(n) предподсч. и O(1) на запрос.
Пусть a1,a2,...,an - статический массив, ищем минимум на отрезке.
Рассмотрим декартово дерево на наборе (1,a1), ..., (n, an)

Утв. Если (k,ak) это LCA точек (i,ai), (j, aj), то ak = min{ai, ..., aj}
// i = key, ai = prior
Док-во:
Засплитим по ключам и получим дерево с элементами (i,ai), ..., (j-1, aj-1), (j, aj)
Вершина в нём - это штука с минимальным приоритетом, а значит минимум на отрезке.
Ну тогда она и до сплита была их общим предком (следует из того, как работает сплит) 
заметим, что она не могла быть не LCA, т.к. иначе по ключу она не лежит в отрезке (i, j)
Ну а значит она LCA.

Осталось научиться строить ДД за О(n). У нас есть отсортированный список вершин по ключам.
Пусть уже построено некоторое дерево и мы добавляем новую вершину с ключом, большим всех.
Тогда она будет самой правой вершиной в дереве.
Будем идти по правому пути в существующем ДД снизу вверх (поддерживаем правую ветку как СТЕК), пока приор. не норм.
И затем подвешиваем нашу вершину справа, а правое поддерево подвешиваем слева.

Ура - мы свели задачу RMQ к LCA, за O(n). Затем мы сведём LCA к RMQ+-1 за О(n) и будем отвечать за О(1).


Heavy-light decomposition (HLD).

Будем решать задачи как на ДО, только в роли отрезков выступают пути в дереве (прибавить на пути, найти сумму там)
На каждом ребре написано число.
Подвесим дерево за r. И посчитаем subtree[v] forall v

Опр. (u, v) - ребро вниз - тяжёлое, если subtree[v] >= 1/2 subtree[u].
Замечание: из каждой вершины выходит не более одного тяжёлого ребра.
Предложение: давайте выделим все эти тяжёлые рёбра и получим выделенные тяжёлые пути.

Задача - 1) update на ребре 
         2) найти сумму чисел на рёбрах между u, v

Утв. На пути u ---> v число лёгких рёбер = O(logn)
Путь u --> LCA --> v. Проход вверх по лёгкому ребру увеличивает размер поддерева хотя бы в два раза, 
а значит таких рёбер на пути u --> LCA и на пути v --> LCA не более log n. ЧТД.

А значит что мы будем находиться в O(log n) различных тяжёлых путях и можем на каждом из них
построить ДО и отвечать на запрос за O(log n)

Итоговая асимптотика ответа на запрос суммы O(log(n) * log(n)), запрос на обновление в точке O(log n)
Предподсчёт наверное линейный:
поиск тяжёлых путей + построение на каждом ДО за О(n) + наверное какой-то предподсчёт для быстрого разбиения пути
    на тяжёло-лёгкие части.

Тут был пример - визуально стоит понять, что тяжёлые пути это такие бабмуки вверх.
            И, к тому же, запрос u-->v действительно разбивается на (u --> LCA) and (LCA --> v)

Задача: Взвеш. дерево и запросы.
    1) Reverse на пути.
    2) Сумма на пути.
Вместо ДО - впилим ДД на тяжёлых путях.
Чтобы ответить на первый вопрос - мысленно создадим увидим путь u-->v и будем выспличивать из нужных деревьев 
на тяжёлых путях нужные кусочки и вставлять их в другие ДД.


Центроидная декомпозиция. (Centroid decomposition)
Пусть задача такая - Дано дерево T, цель - найти число объектов в дереве со св-м Альфа.
Например - цель найти |{(u,v,w) , dist(u, v) = dist(v, w) = dist(u, w)}|  // кол-во троек

План:
Пусть с - центроид Т. 
Предположим, что мы его удалим. Тогда давайте найдём число интересующих объектов, которые используют с.
Теперь удаляем с и имеем Т1, ..., Tk и решаем задачу рекурсивно на этих деревьях.
Поскольку размер деревьев уменьшается хотя бы в два раза, то глубина рекурсии O(logn)
Тогда если мы умели решать задачу, поиска объектов, исп. с за О(tree_size), то суммарно получим O(nlogn)  
Ибо каждая вершина участвовала не более чем в logn деревьях, А значит суммарный размер деревьев O(nlogn)

Второй тип задач на центроид.
Дано дерево - каждая вершина синяя или красная.
Запросы:
    1) дано v -> пекрась синюю v в красный цвет
    2) u - найти расстояние от u до ближ. красной к ней.
План:
Построим дерево центродов. Глубина дерева - logn.
Корень - первый центроид. Его сыновья - вторые центроиды.

Пусть Tv - дерево в момент, когда v - центроид.
Для каждой v хочу хранить closest[v] = min{dist(v, r), r in Tv, r - red}
Запрос 2): Ans = min(dist(u, v) + closest[v] | u - предок v в дереве центроидов).
O(logn logn), т.к. поиск dist(u, v) = logn и высота дерева O(logn)

Запрос 1)-типа: по всем v - предкам r в дереве центроидов closest[v] = min(closest[v], dist(v, r))
O(logn logn) - ан-но

Вопрос - почему работает формула с Ans.
