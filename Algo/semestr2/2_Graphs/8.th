Потоки.
Мотивация:
Существует ориентированый взвешенный граф.
Цель - по нему из стартовой в конечную вершину передать как можно больше единиц, так
чтобы поток единиц по каждому ребру не превосходил веса ребра. В некотором смысле водопровод и вода.

Сеть - (G, s, t, c)
G - ориент. граф, без петель и кратных рёбер.
s - исток, t - сток.
c: Edges -> Z. Каждому ребру сопоставляет пропускную способность. // Capacity.

Опр. Поток f в сети G:
    f: VxV -> Z
1) forall u, v in Vertexes: f(u, v) <= c(u, v)
    // if (u, v) not in E => c(u, v) = 0
2) Закон сохранения потока: forall v in V \ {s,t}
    Summ(f(u,v)) = Summ(f(v, w))
3) Антисимметричность: f(u, v) = - f(v, u)

Опр. Величиной потока |f| называется сумма forall v in V: f(s, v)

Зачем нам нужны отрицательные потоки?
Пример: Тот самый дефолтный ромб с одним вертикальным ребром и s - слева, t - справа.
Очев |f| = 2 (исключительно по рёбрам ромба)
Если мы уже нашли поток через серединное ребро, тогда благодаря отриц. рёбрам мы можем 
"перенаправить", поток идущий через него и построить ещё один.

Опр. Пусть G - сеть, f - поток в ней. Остаточная сеть Gf: c_f(u, v) = c(u, v) - f(u, v)
    // Т.е. новые капасити у рёбер. Рёбра с c_f = 0 не учитываются.

Теорема Форда - Фалкерсона.
f - максимально <=> в Gf нет пути из s в t.

Опр. G - сеть. (S, T) - разрез, если s in S, t in T: S + T = V (дизъюнктной объединение)
Опр. Величина разреза: c(S, T) = Summ(u in S, v in T: c(u, v))
Опр. Величина потока через разрез: f(S, T) = Summ(u in S, v in T: f(u, v)).

Лемма. Для любого разреза (S, T) и потока f:
|f| = f(S, T)
Интуитивно: Вся водичка, прошедшая через сеть - проходит через разрез.
Док-во: пусть S = {s, v1, ..., vk}
Рассмотрим разрез: (S, T) = ({s}, V\{s})
    f({s}, V\{s}) = Summ(v in V\{s}: f(s, v)) = Summ(v in V: f(s, v)) = |f| , т.к. f(s, s) = 0 по антисимм.
Положим U = {s, v1, ..., vi} 
Пусть известно f(U, ...) = |f|
Тогда f(U \/ {v_i+1}, ...) = f(U, ...) - Summ(u in U: f(u, v_i+1)) + Summ(w not in U: f(v_i+1, w))
Картинка: U ->-> v_i+1 ->-> [not U \/ {v_i+1}]
Хочется показать, что Summ(u in U: f(u, v_i+1)) == Summ(w not in U: f(v_i+1, w))

Запишем закон сохранения потока:
Summ(w in V: f(v_i+1, w)) = Summ(w in V: f(w, v_i+1))
Summ(w in U: f(v_i+1, w)) + Summ(w in V\U: f(v_i+1, w)) = Summ(w in U: f(w, v_i+1)) + Summ(w in V\U: f(w, v_i+1))
A + B = - A - B
A = -B
Откуда следует Summ(u in U: f(u, v_i+1)) == Summ(w not in U: f(v_i+1, w))
А значит f(U \/ {v_i+1}, ...) = f(U, ...) = |f|. По индукции доказано.

Лемма. Величина любого потока <= величина любого разреза.
Док-во: Фиксируем f, разрез (S, T). Покажем |f| <= c(S, T)
Верно |f| = f(S, T) <= c(S, T)
Последнее неравенство очевидно, т.к. f(u, v) <= c(u, v), forall(u, v)

Приступим к док-ву Теоремы Форда-Фалкерсона.
СУЭ.
1) f - max поток
2) в Gf нет пути из s в t (т.е. относительно f нет увеличивающего пути)
3) Существует (S, T) разрез, т.ч. |f| = c(S, T)

Док-во:
1=>2. Пусть есть увеличивающий путь относительно максимального потока.
Увеличим поток вдоль него - противоречие с максимальностью потока.
2=>3. Пусть S - множество достижимых вершин из s в Gf. Очев. t not in S по утв-2. Определим T = V \ S.
Поскольку вершины в T, соседние с S, недостижимы из s, то по разрезным рёбрам течёт максимальный возможный поток.
А значит f(u, v) = c(u, v), а значит |f| = f(S, T) = c(S, T), ч.т.д.
3=>1.
Поскольку |f| <= c(S, T) для любых S, T, то в случае |f| = c(S, T) для нек S, T - то он максимальный из возможных.

Отсюда следует алгоритм Форда - Фалкерсона:
Пока в Gf есть путь из s в t:
    Найти минимальный cf на этом пути
    Протолкнуть такой поток вдаоль этого пути (В т.ч. перестроить Gf)

Пример, где работает медленно: 
    Тот самый ромб с вертикальной диагональю, где на его рёбрах 10^9, на диагонали 1.
    На таком графе работать будем 10^9 * 2 в худшем случае.
Асимптотика ФФ: O(|f| * dfs) = O(ans * m)

Алгоритм Эдмондса - Карпа.
На каждой итерации алгоритма ФФ. находим кртачайший путь по числу рёбер.

Утв-е: Итераций в алгоритме O(V * E) -> Асимптотика O(V * E * E)
    Перед док-вом нужно узнать нек-ые факты

Лемма: Пусть f и f' два последовательных потока в алгоритме ЭК.
Пусть d[v] = dist(s, v) в Gf, d'[v] = dist(s, v) в Gf'
    Тогда, forall v: d'[v] >= d[v]
Док-во:
    1) v = s => d'[s] = 0 = d[s]
    2) Пусть не выполняется для каких-то v != s. Для них d'[v] < d[v]
    Среди них найдём v, т.ч. d'[v] - минимально.
    Рассмотрим также u - последнюю вершину на кратчайшем пути из s -> v.
    Верно d'[u] + 1 = d'[v]
    Сл-но d'[u] < d[v] => d'[u] >= d[u]
    * Спросим себя теперь - Почему (u, v) есть в Gf'?
    1) (u, v) было в Gf и оно не исчезло после пропускания потока.
        d[v] <= d[u] + 1 <= d'[u] + 1 = d'[v]  -  Противоречие с тем, что d'[v] < d[v]
        // Первое нерав-во явл. новым
    2) (u, v) появляетсяв Gf' за счёт того, что по ребру (v, u) пустили какой-то поток.
        Это значит что вдоль (v, u) проходит кратчайший путь s -> t.
        А значит d[u] = d[v] + 1
        В Свою очередь d[u] <= d'[u] = d'[v] - 1
        Откуда d[v] + 2 <= d'[v]
        Мы предположили же, что d'[v] < d[v] - Противоречие!
    А значит ни одной такой вершины с d'[v] < d[v] не существует!
    Зафиксируем результат: d'[v] >= d[v]    

Опр. Говорим, что ребро насыщается, когда f(u, v) = c(u, v)

Лемма: в ЭК каждое ребро насыщается O(V) раз.
    Док-во позже.

Следствие: Кол-во итераций = O(V * E)
    // Каждая итерация насыщает хотя бы одно ребро.

Док-во леммы:
    Пусть (u, v) насытилось. Чтобы насытиться ещё раз, оно должно "разнасытиться", а значит
    По обратному ребру сначала должен быть пущен поток хотя бы 1.
    Т.е. должен проходить кратчайший путь через ребро (v, u)
    Пусть d[v] - кратчайшее расстояние в первый момент времени(u, v - насытилось)
    d' - во второй(нашли кр. путь через v, u)
    Мы знаем d[v] = d[u] + 1;
    Мы знаем d'[v] >= d[v] по Лемме.
    Теперь d'[u] = d'[v] + 1
    Склеим: d'[u] = d'[v] + 1 >= d[v] + 1 = d[u] + 2
    Т.е. чтобы ещё раз насытить (u, v), необходимо увеличить d[u] хотя бы на 2, а значит
    Всилу ограничения на d[x] <= |V| => (u, v) насытится [ <= |V| / 2 раз ]
    
Пример задачи на ЭК.
    Дано n человек - все должны разбиться на математиков и программистов.
    У каждого человека есть два числа - степень отвращения к математике и программированию.
    Есть также рёбра - дружба. Если они в разных группах, то уровень отвращения также повысится.
    Уровень отвращения есть сумма отвращений.
---
Построим сеть.
s,t, и по вершине на каждого человека.
s --(ai)--> i --(bi)--> t. Где ai, bi - отвращение к матматике и прогр. соотв.
i <--c_ij--> j, где c_ij - уровень дружбы между i,j людьми.
Min Cut в этом графе соответствует минимальному недовольству. 
Пусть мы разделили всех людей на группы S, T - программисты и математики соотв.
Тогда рассмотрим разрез (S, T). Заметим, что величина недовольства = c(S, T) = величина разреза.
    // рав-во следует из построенных рёбер.
Искать Min Cat <=> Искать минимальный поток по теореме ФФ.
