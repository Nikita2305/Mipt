Потоки(3) - Глобальные разрезы.

Опр. (S, T) - глобальный разрез, что S,T != 0 и S + T = V. (Не обяз. s in S, t in T)
c(S, T) = Sum(c(u, v) | u,v in V)
Будем писать c(S) = c(T) = c(S, T) в случае неор. графов. (т.е. c(S, T) = c(T, S))

Цель: найти min/max глобальный разрез в G.
Поиск max разреза даже в невзвеш. графе (с(u, v) <= 1). NP - трудная, т.е. не решается за полином.

NP сложные.
-> Max Clique
-> Сущ. гам. пути 
-> max IS
-> min VC
-> Max Cut
-> Поиск хром. цвета для графа (миним. набор цветов)

Решим задачу поиска минимального разреза во взвеш. неориент. графе
Алгоритм(самый простой):
    ans = inf
    for s = 1..n
        for t = s+1..n
            ans = min(ans, FLOW(s,t))

Или даже
    ans = inf
    for (t = 2..n)
        ans = min(ans, FLOW(1, t))
Асимптотика: O(v * FLOW) = O(V^3 * E)

Основано на Т.ФФ, ибо MAXFLOW = мин. разрез.

Если граф невзвеш., то алгоритм работает быстрее, т.к. сеть единичная



Алгоритм Штор-Вагнера.
Пусть a_1 = 1, А_i = {a_1, ..., a_i}
a_i+1 = argmax {c(v, Ai) | v not in Ai}
...
An = {1, 2, ..., n}
УТВ: Тогда минимальный разрез между a_n и a_n-1 есть (a_n, V \ {an})

Тогда либо уже найден min cut, либо a_n и a_n-1 можно склеить.
Асимптотика: O(V^3) // V раз по V^2

Док-во УТВ:
Пусть ({a_n}, V \ {a_n}) не MinCut, пусть C - наст. min cut. C = (S, T).

--------------
Опр. Назовём a_i активной, если a_i и a_i-1 лежат в разных частях разреза C.

Лемма: Докажем, что с({a_i}, A_i-1) <= c(S /\ A_i, T /\ Ai) для любой активной a_i

Рассмотрим a_j - первая активная. Тогда a1...aj-1 in S, a_j in T.
Заметим тогда: c({aj}, A_j-1) = с(T /\ Ai, S /\ Ai), искомое неравенство обращается в равенство
Это была типа база индукции.

А вот типа переход:
Пусть a_u, a_v - две последовательные активные. (u < v)
с({a_v}, A_v-1) = c({a_v}, A_u-1) + c({a_v}, Av-1 \ Au-1)

Заметим: c({a_v}, A_u-1) <= c({a_u}, Au-1) // оценили первое слагаемое.
    Притом можно продолжить нераество по предп. индукции.

Заметим, что если рассмотреть отличие c(S /\ Au, T /\ Au)
                    от новой версии: c(S /\ Av, T /\ Av), то
Влево(в S) добавилась a_v, вправо(в T) добавилось a_u+1, ... av-1
Тогда их разница - хотя бы c({a_v}, Av-1 \ Au-1) // Откуда-то взялось a_u в этой сумме?

Откуда, продолжая исходное нерав-во:
<= c({a_u}, Au-1) + c({a_v}, Av-1 \ Au-1) <=
<= c(S /\ Au, T /\ Au) + (c(S /\ Av, T /\ Av)- c(S /\ Au, T /\ Au)) = c(S /\ Av, T /\ Av) 
-------------

Последняя вершина обязательно активна, т.к. a_n лежит в S, a_n-1 in T.
Тогда c({a_n}, An-1) <= c(S /\ An, T /\ An) = c(S, T)



Потоки минимальной стоимости (min cost flows)

Теперь Edge = (u,v,capacity,cost)
Штраф пропускания f-потока по ребру: f * cost
Возникает задача: MinCost k-flow - поиск потока величины k min стоимости

Алгоритм поиска min-cost k-flow.
k раз пропустить единицу потока вдоль дешевейшего пути(будем называть его кратчайшим)
Как строить остаточную сеть: обратное ребро будет иметь цену -p.

Для поиска кратчайшего пути используем Форда-Беллмана. Планируем бороться с отр. циклами.
Асимптотика: O(k * FB) = O(k * V * E)

Важное для рассуждений выше:
Утв (критерий): Пусть f - поток величины k.
Тогда f - mincost k-flow <=> в Gf нет отрицательных циклов.

Д-во:
=>. Пусть f - mincost k-flow и в Gf есть отрицательный цикл.
Тогда после пропускания единица потока вдоль этого цикла -
величина потока не изменится, а стоимость уменьшится.

<=. Пусть нет отрицательных циклов, но и f - не mincost k-flow.
Пусть тогда f* - mincost k-flow.
Определим g = f* - f.
Тогда g - поток вдоль нескольких циклов (циркуляция). Поток g величины 0.
cost(g) < 0 => хотя бы один цикл отрицательный, противоречие.

Утв: Алгоритм поиска min cost k-flow после i итераций находит min cost i-flow.
    (если в исх. G не было отр. циклов)
Д-во: f_0 = 0 - mincost 0-flow - база индукции.
Согласно критерию f - mincost - достаточно показать, что 
при переходе fi -> fi+1 не возникает отр. циклов в G_fi+1,
т.е. при проталкивании потока вдоль пути p их не возникнет.

Пусть возникает цикл С, который использует рёбра p.
Тогда p + C - путь из s->t (+ циклы) в Gfi веса меньше чем P
Тогда либо p - не кратчайший, либо в Gfi был отрицаьтельный - противоречие.

Корректность: на каждом шаге отриц. циклов не появляется, а значит на каждом шаге нашёлся реальный Min Flow.



Потенциалы Джонсона. Алгоритмы Дейкстры-Джонсона.

Пусть phi: V->Z - потенциальная функция.
Пусть cost_phi(u, v) = cost(u, v) + phi(u) - phi(v)

Замечание: Такое преобразование не меняет кратчайших путей.
cost_phi(path) = cost(path) + (phi(s) - phi(t)) = cost(path) + CONST.

С помощью этой потенциальной функции хотим cost_phi(u, v) >= 0 forall (u, v) in Gf
Запустим FB из s. || phi(v) = dist(s, v) ||
Тогда cost_phi(u, v) = cost(u, v) + dist(s, u) - dist(s, v) >= 0, по "нерав. треуг."

Запустим алгоритм Дейкстры на G с весовой функцией cost_phi.
Утв. Кратчайший путь s->t имеет вес 0, притом dist_phi(s, v) = 0 forall v on path(s->t)
Док-во: Он и был кратчайшим на весовой cost. Тогда dist(s,u) + cost(u, v) = dist(s, v)
    Откуда cost_phi(u, v) = 0.

А значит нада найти путь по 0-рёбрам. В остаточной сети должны появиться также 0 рёбра
Т.е. было w + phi(u) - phi(v) = 0, стало -w + phi(v) - phi(u). Оно тоже = 0.

Пусть psi(v) = dist_cost_phi(s, v) = расстояние, которые находит дейкстра в сети с cost_phi
Увеличим наш потенциал phi(v) += psi(v). Хочется верить, что это вновь хороший потенциал.

Реализация:
def applyPotentials(phi, G):
    forall u,v cost(u, v) += phi(u) - phi(v)

mincost_k_flow(k):
    phi = FB(s, G)
    applyPotentials(phi, G)
    for i = 1..k:
        psi = Dijkstra(s, G)
        pushflow()
        applyPotentials(psi)

Асимптотика: V*E + k * E * logV  //Или V*E + k*V*V
Вывод: т.е. с помощью потенциалов мы научились запускать FB всего один раз.

Замечание: в случае исключительно положительных рёбер, то FB можно заменить на Dijktra.

Замечание: решение задачи MinCostMaxFlow.
    Передай k = inf
    Если Дейкстра не нашла пути, то return;


Применение: Задача о назначениях.

Дан взвешенный полный двудольный граф.
Цель - найти совершенное парсоч. минимального веса.
Интерпретация: в левой доле работники, в правой доле - рабочие задачи, веса - зарплата за выполнение.

Решение: создаём s,t и как и в задаче Хопкрофта-Карпа проводим рёбра cap = 1, cost = 0.
Задача сводится к поиску MinCostMaxFlow или MinCost n-Flow.
Асимптотика: O(n^3)
