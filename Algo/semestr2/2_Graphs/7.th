Паросочетания.
Опр. Пусть G это граф, то М - подмножество рёбер G, такое что никакой вершине не инцидентно два ребра из М
    называется паросочетанием.
Целью будет являться: найти М, паросочетание максимальной мощности.
Решать задачу будем в двудольном графе. Доли будем обозначать L и R.

Опр. Пусть задан двудольный граф G и на нём парсоч. М.
Увеличивающей цепью назовём такой путь в G, который начинается в вершинах, не насыщенных M
И типы рёбер чередуются: не_из_парсоч - из_парсоч.
В том числе Увеличивающей цепью является ребро, с ненасыщенными концами.

Утверждение: инвертируя типы рёбер на пути - увеличим количество рёбер в М на 1.
М останется паросочетанием.

Теорема Бержа.
М - максимально <=> относительно М нет увеличивающих путей.
Д-во:
=>. Пусть путь есть, тогда увеличим парсоч - противоречие, т.к. М - максимально.
<=.
Лемма. Если h - неориент. граф, где степень каждой вершины <= 2.
Тогда любая компонента - изол. вершина, бамбук или замкнутый цикл.
    Д-во: по очереди отбросим вершины степени 0, 1 и 2, отбрасывая изол. вершины, бамбук и цикл соотв.
--Продолжим док-во.
Пусть М' максимальное парсоч большей чем М мощности.
Рассмотрим множество рёбер - Симм. разность M и M' - те что лежат ровно в одном.
Тогда на таком графе H у кажд. вершины степень <= 2, тогда по Лемме:
H - объединение путей и циклов.
В любой компоненте H рёбра чередуются - из М / из M' / из М ...
Тогда в любой компоненте ~ одинаково рёбер разных типов. Посмотрим где будет отличаться.
Нечётных циклов нет(т.к. граф G - двудольный, но можно не исп. этот факт), т.к. рёбра из M/M' - чередуются.
Единственное место, где может отличаться - нечётные пути.
Заметим это как раз увеличивающий путь!
Осталось показать, что крайние вершины не насыщены рёбрами из M. Очевидно они не насыщенны рёбрами из M/M'
Если же они насыщены ребром из M & M', тогда противоречие, т.к. два ребра из M' встретятся в крайней вершине.
Противоречие с правой частью равносильности!

Нашим алгоритмом будет что-то такое:
Пока есть увеличивающий путь - сделаем чередование вдоль него.

Алгоритм Куна.
// Пусть слева n вершинок, справа k вершинок.
vector<vector<int>> L(n);
vector<bool> used(n);
vector<int> match(k, -1);

bool findPath(int v) { // Нашли ли увеличивающий путь
    if (used[v]) return false;
    used[v] = true;
    for (int to: L[v]) {
        if (match[to] == -1){
            match[to] = v;
            return true;
        } else {
            if(findPath(match[to]))
                return true
        }
    }
    return false;
}

main:
    for (int v = 0; v < n; v++) {
        if (findPath(v)) {
            used.assign(n, false);
        }
    }
Асимптотика: O(ans * (n + m))
Но почему всего один проход по вершинам?

Утверждение: Если из x не существует увеличивающего пути относительно M, то из x не будет и увеличивающего пути
относительно M' (где M' получено из M чередованием вдоль увеличивающего пути)
    Д-во:
M'(y) - М - М' - M - M' - M - M'(z) // - тот путь по которому мы увеличили M -> M'
Пусть есть вершина x, из которой есть увеличивающий путь в M'. (не обяз. лежит на пути)
Тогда этот увел. путь пересекается с путём выше(иначе очев. он лежит и в М)
Пусть вершина первого пересечения - p.
Заметим, что все рёбра между p и x - чередование: не из M' / из M' ... Также, т.к. p - первая вершина пересеч.
То это равносильно чередованию: (не из M) / (из M) / ...
    // не забываем, что путь y->z - единственное изменение между M и M'
Рассматривая случаи относительно последнего ребра в таком чередовании (ближайшего к p) - найдём
увеличивающие пути относительно M, исходящие из х.
Противоречие, т.к. утверждалось что увел. пути относительно М не было.

Опр. Пусть G - граф. I - подмножество вершин G.
I - независимое множество G, если ни одно ребро из G не соединяет вершины из I.

Опр. Пусть G - граф. С - подмножество вершин G.
С - вершинное покрытие, если любое ребро из G хотя бы одним концом лежит в C.

Упр. I - независимое множество <=> V\I - верш. покрытие

Цель: В двудольном графе.
Найти max independent set и min vertex cover.

Решение: 
Пусть в G найдено M - макс парсоч. 
Пусть рёбра из M ориентированы справа налево, остальные рёбра слева направо(двуд. граф)
Запустим объод из всех ненасыщенных вершин левой доли.
Всё, что достижимо, пометим посещёнными.
Наш граф распадается на 4 части:
L-  R-
 
L+  R+

Утв.
L- & R+  // min VC
L+ & R-  // max IS

Док-во.
1) Нет рёбер из R+ в L-  // очевидно
2) Нет рёбер из L+ в R-  // очевидно
    Т.к. иначе мы бы по ним прошли во время обхода.
3) Нет рёбер из R- в L+
    Пусть оно такое есть. Значит оно из парсоча. Значит оно насытило вершину из L+.
    Она в L+, значит посещена, но запустились не из неё(пред. предлож.), а значит как-то в неё пришли.
    Прийти в неё могли только по рассмотренному ребру, а значит противоречие, т.к. его конец в R-(непосещ.)
По утв-ям 1-3 (L+ & R-) - IS, а тогда (L- & R+) - VC
Покажем минимальность / максимальность.

Покажем (L- & R+) - Min. VC.
+ Сперва покажем, что мощность |L- & R+| <= |M|
    * In L- лежат только насыщ. вершины // Все ненасыщ. лежат в L+, т.к. из них запускали dfs.
    * In R+ лежат только насыщ. вершины // Иначе есть увелич. путь.
    * Никакое ребро из паросочетание не инцидентно одновременно L- и R+. (По факту (1) из этого Док-ва)
По этим фактам следует доказываемое.

+ Покажем, что |VC| >= |M| // очевидно, т.к. каждому ребру из M нужно хотя бы по одной вершине.

Отсюда следует, что мы победили.

-----

Более естественный подход к решению задачи о поиске VC
|VC| = |MM| // Max matching
Так что с каждого ребра по вершинке.
А значит можно свести задачу к 2-SAT.
Утв-ся, что асимптотика будет аналогичной.
