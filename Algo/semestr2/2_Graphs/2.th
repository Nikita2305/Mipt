Лекция про компоненты сильной связности и т.п.

Опр. В графе вершины a,b сильно связны, если есть путь между ними в обе стороны.
Утв. Сильная связность - отношение эквивалентности, понятно из рефл, транз, симм.
Наша ближ. цель - разбить граф на классы эквивалентности(или комп. сильной связности).

Алгоритм Косарайю.
1) Получим топсорт. (пушбэк в конце + ревёрс) //думай об этом как о массиве с убывающим tout.
2) Реверснем граф.
3) В порядке топсорта будем искать КСС на рев графе с помощью DFS.

Док-во корректности:
1) После первого запуска DFS на рев. графе - посетим хотя бы всю КСС - очев.
2) Если u, v - вершины разных КСС, то они не будут отнесены к одной КСС алгоритмом.
    Имеет место один из двух вариантов, не умаляя общности.
    1. нет путей никаких.
    2. есть путь только u->v
//Кажется для простоты можно просто сказать, что нет пути v->u.

Первый случай сводится ко второму(подумай о случае с компонентой от вершины w, которая достижима из u,v) = В этом случае достаточно показать, что 
из u -> w (но не наоборот), слеует, что u и w будут отнесены к разным компонентам.

Второй случай:
    Утв. u->v, сл-но tout[u] > tout[v].
    Два случая - либо мы раньше посетим u, тогда очев.
        либо мы раньше посетим v, тогда очев.(ибо нет пути из v->u)
А значит dfsR(u) на RevGraph запустится раньше чем dfsR(v), а значит всилу несуществования пути v->u,
т.е. в revGr несуществования пути u->v, dfsR(u) не посетит вершину v, победа.
Асимптотика O(n + m)

Конденсация графа - помимо поиска КСС, в dfsR() будем ещё и добавлять рёбра в другие компоненты.
Не забудем также убрать кратные рёбра.
Всилу док-ва корректности в сконденс. графе нет циклов. Пусть есть, тогда там получится КСС,
но док-во корректности утверждает что нет, противоречие.


Применение: 2-SAT.
Дана 2-КНФ, т.е. (x or y) and (x or not z) and (...) ... .Цель: узнать выполнима ли она и найти вып. набор.
Каждой вершине сопоставим две вершины, p и not(p).
Затем каждой скобке вида (a or b) сопоставим ребро not(a) -> b, not(b) -> a.

2-КНФ невыполнима <=> сущ. p и not(p) в одной КСС.
Утв. Если какая-то вершина истина, то и любая вершина, достижимая из неё по стрелкам - тоже истинная.
<= - верна очев.
=> - докажем приведением примера. Вспоминая алгоритм Косарайю - он выделяет компоненты в нек. порядке.
Пусть С(v) - номер компоненты КСС от v в этом порядке.
Набор:
    p = 1, если C(p) > C(not(p))
    p = 0, если C(p) < C(not(p))
Пусть такой набор невыполняющий. Тогда сущ. (x or y), т.ч. C(x) < C(not(x)), C(y) < C(not(y))
Но в графе есть рёбра not(x) -> y, not(y) -> x. Ну тогда C(not(y)) <= C(x) < C(not(x)) <= C(y) < C(not(y)),
исходя из порядка выделяемых компонент(в первом нер-ве верно, что tout[x] < tout[not(y)])

Асимптотика: O(n + m), где n - кол-во переменных, m - число скобок.


DFS в неориент. графах.
Интересный факт - нет рёбер из нынешней вершины в чёрную, т.к. иначе мы бы по нему прошли в обратную сторону ранее
Рёбра вниз - древесные рёбра. Все другие - обратные рёбра.
Проверка на связность - очев, проверка на ацикличность - проверка used[t] and t != par.


Мосты и точки сочленения - штуки которые при выбрасывании сделают граф несвязным.
Введём ret[v] = min(tin[v], tin[u]) , где u - все такие вершины,
достижимые из v - несколькими прыжками вниз по древ. рёбрам, а затем один раз вверх по обр. ребру.

Утв. Обратные рёбра - точно не мосты.
Утв2. Ребро (u,v) - мост <=> ret[v] == tin[v]

Напишем DFS.
Внутри скипаем to == p,
Для обратных рёбер обновляем ret[v] через tin[to]
Для сыновей в дереве:
    dfs(to, v)
    if(ret[to] >= tin[to])
        (v,to) - мост
    ret[v] = min(ret[v], ret[to])

