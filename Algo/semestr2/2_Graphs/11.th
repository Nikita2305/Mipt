Деревья.

Опр. Дерево - связный безцикловый граф.
Св-ва:
    1) Рёбер |E| = |V| - 1
    2) Существует единственный путь между любыми двумя вершинами.

Опр. 
Пусть G - произв. неор. невзвеш. граф.
Тогда диаметром G назовём max(dist(s,t) | s,t in V)

Замечание: В произвольном графе ищется Флойдом за O(n^3)

Алгоритм поиска диаметра в дереве за О(n)
Рассмотрим x - произвольная вершина.
y - самая далёкая от x. Через dfs.
z - самая далёкая от y. Через dfs.

Док-во корректности.
Заметим, какова структура дерева, подвешенного на диаметре L,R.
Max высоты деревьев: 0, 1, 2, 3, 4, 3, 2, 1, 0
Тогда заметим, что из любой вершины - самая дальняя это L or R.
Очевидно - второй итерацией мы найдём диаметр.


Опр. G - дерево, v in V. Тогда v - центроид, если
    после удаления v дерево распадается на компоненты размера <= n/2

Утв1. В любом дереве есть центроид.
Утв2 (б/д). В любом дереве
    Либо есть единтсвенный центроид.
    Либо есть 2 центроида, которые соединены ребром.

Алгоритм поиска центроида, док-ий Утв1.
Пусть r - корень.
Пусть subtree[v] - размер поддерева вершины v.
Вывод: c - центроид <=> subtree[c] >= n/2
                        subtree[c.son] < n/2
Решение - иди вниз по дереву, пока subtree[v] >= n/2



Изоморфизм.

Опр. G и H - два графа.
    phi: V(G) -> V(H)
    1) phi - биекция
    2) (u, v) in E(G) <=> (phi(u), phi(v)) in E(H)
Тогда G и H - изоморфны.

1) Случай ор. подвешенных деревьев. - проверить что изоморфны

Пусть G - фикс. корневое дерево.
Найдём "номер класса экв-ти" для всех поддер-в
База: лист == {} = класс 0
Переход: будем считать поддерево с корнем
    v.вектор == {class[to_1], ..., class[to_k]}
И если v.вектор не встречался (через map), то его назовём iter++;

Повторим тоже самое с H на той же памяти (u_map<vector<int>:int>)
И просто проверим, что G.name == H.name
РЕШЕНО.

Замечание: векторы {1,1,2} and {1,2,1} отличаются.
    Т.е. графы с разл. порядком поддеревьев отличаются

2) Случай неподвешенных деревьев.
Если раньше мы могли понимать, что корень перейдёт в корень,
то теперь будем использовать центроид. По утв2 - их не более 2
Поэтому можно перебрать 2 возможных варианта и проверить на изоморф.
как раньше.



Задача LCA.
LCA - least common ancestor - наим. общий предок. (самый низкий)
Цель - отвечать на запросы findLCA(x, y).



Сразу напишем вспомогательную
bool isAncestor(int p, int s) {
    return tin[p] <= tin[s] && tout[p] >= tout[s];
}

Используем метод двоичных подъёмов.
shifts[k][v] = (предок на высоте 2^k вершины v) or (root)
База: shifts[0][v] = p[v]
Переход: shifts[k][v] = shifts[k-1][shifts[k-1][v]]

Теперь int lca(int u, int v) {
    if (isAncestor(u, v))
        return u;
    for (int k = max, k >= 0; k--)
        if (!isAnc(shifts[k][u], v))
            u = shifts[k][u];
    return par[u];
}

Предподсчёт за О(n log n). Запрос O(log n)

Упр. - избавиться от isAncestor, но использовать массив глубин.


Второй метод - Sparse Table на эйлеровом обходе.
Утв: между первыми вхождениями u, v в эйлеров обход - 
    лежит их LCA и нет других общих предков.
Док-во: через рассмотрение дерева с вершинами u, v, LCA

Вывод: найти вершину с минимальной высотой или tin 
на отрезке first[u]; first[v] массива euler.
Решение: через O(nlogn) предподсчёта + O(1) на запрос.


Пример использования эйлерова обхода:
1) прибавление на поддереве
2) запрос в точке

Утверждение: поддерево есть подотрезок эйл. обхода.
Достаточно использовать дерево отрезков на эйл. обходе
