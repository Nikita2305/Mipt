Графы.

[Не]ориентированный граф.
E - edges, V - vertexes.
По умолч. кр. рёбер нет.

Если G - граф, то v1, v2, ..., vk - путь, если (vi, v_i+1) лежат в E.
Путь называется рёберно простым, если в нём нет повторяющихся рёбер. Формально в оринт. графе [x, y, x] - простой
Путь называется вершинно простым(или простым), если в нём нет повторяющихся вершин.

Замеч. Если путь вершинно прост, то он и рёберно прост.
Опр. Цикл - путь, в котором первая и последняя вершина совпадают.
Сюда наследуется и опр. рёберно и вершинно простым циклом(аккуратно про первую и посл. вершину).

Опр. Пусть u, v in V(G). Говорим, что из u достижива v, если существует путь, начин в u и зак. в v.
    Замеч. Если есть какой-то путь, то есть и простой путь(будем обрезать петли, которые мы накручиваем).

Опр. Неориент. граф G связен, если между любыми двумя вершинами: из u достиж v.

Способы хранения графа.
1) Матрица смежности. bool m[i][j] - есть ли ребро i -> j. O(1) - проверка, но W(n^2) - памяти
2) Список рёбер. 
3) Списки смежности - наиболее классный способ. O(n + m).

Если граф фиксированный, то можно решить проблему доступа к ребру с помощью
    Fixed Set - решение такой задачи с помощью совершенного хэширования.



vector<vector<int>> g;
vector<int> tin, tout; //здесь мы будем видеть время входа и выхода
int timer = 0; //здесь будет временной счётчик
vector<string> color(n, "white"); //здесь будут промежуточные цвета и полезно для связности.
vector<int> par; //здесь будут родители вершин в дереве дфс

void dfs(int v, int p = -1){
    par[v] = p;
    color[v] = "grey";
    tin[v] = timer++;
    for (int to: g[v]) {
        if (color[to] != "white")
            continue;
        dfs(to, v);
    }
    tout[v] = timer++;
    color[v] = "black";
}

Лемма(о белых путях).
    Все пути, бывшие белыми, в момент tin[v], начинающиеся в v - станут чёрными целиком к моменту tout[v].
Доказательство: 
Индукция по убыванию времени tin[v].
База: какая-то очев. Типа к моменту самого позднего tin[v] нет вообще белых вершин)
Переход. Пусть есть некоторый белый путь. Пусть к моменту tout[v] не все вершины в нём чёрные.
Рассмотрим u - самую верхнюю не чёрную(белая/серая).
    Если она белая, то значит в силу того, что предыдущая(соседняя) чёрная, то противоречие.
    Если она серая, то tin[v] < tin[u] < tout[v] < tout[u] - противоречие

Следствие. Если dfs(s) вызвать, то будет посещено всё, что достижимо из s.
DFS = Depth First Search - поиск в глубину. 

Следствие. В графе есть цикл достижимый из s <=> dfs когда-нибудь находит ребро в color[to] = "grey"
    <=. Вполне очевидное дело. Стэк рекурсии - это путь из серых вершин.
    =>. Пусть С - цикл, достиж. из s.
        Пусть v - первая посещённая вершина C. Тогда в момент tin(v) - весь C - белый.
        К моменту tout[v] - посетится весь С по Лемме.
        В частности предыдущая вершина u из цикла(думая о напр. графах)
        А значит мы найдём ребро (u, v) - ребро в серую вершину.

Замечание. Мы и не ставим себе цель найти все циклы. И это сложно.
Чтобы восстановить цикл - восстановим его из p[i] - то откуда пришли.

Опр. Граф называется ациклическим, если в нём нет циклов. DAG - directed acyclic graph.
Опр. Топологическая сортировка DAG - есть последоавтельность его вершин, что рёбра идут только слева направо.

Пример смежной задачи - подсчёт кол-ва путей DAG - графа.
    Составим топсорт и положим dp[i] - кол-во путей со стартом в topsort[i].
    Тогда dp[i] = 1 + sum(to: g[topsort[i]], dp[to]);

Алгоритм построения топ. сорт.
for (int s = 0; s < n; ++s) {
    if (!used[s])
        dfs(s);
}

Затем вывести вершины в порядке убывания tout.
Почeму ок? Пусть (u, v) in E. Покажем, что u выведется раньше, чем u.
(или, что равносильно: tout[u] > tout[v])
    1) (v посещено раньше) Пусть tin[v] < tin[u]. Тогда в в момент выхода из v, u - ещё не посещена.
        Иначе есть путь из v в u, а значит есть цикл u -> v -> ... -> u.
        А значит tout[u] > tout[v], очев.
    2) (u посещено раньше) Пусть tin[u] < tin[v]. Тогда по Лемме о б.п. tout[v] < tout[u] (мы почерним u).
Алгоритм показан полностью. Асимптотика O(n + m). Каждая вершина и каждое ребро просм. один раз - кас. dfs.

Тут был пример.
