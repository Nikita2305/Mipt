 Задача о рюкзаке.
n - предметов, wi - вес, ci - стоимость
Цель - собрать неск. предметов веса <= W, наиб. стоимости

1) dp[i][w] - макс. стоимость взятия неск. предметов среди первых i, веса ровно w.
dp[i][w] = max(dp[i-1][w], dp[i-1][w - w[i]] + c[i]);
Time = _O_(n * W). Память _O_(n * W).
Замечание: пока никто не умеет решать данную задачу за полиномиальное время(от размера входа в битах).
Замечание: тривиальная жадность не работает. Пример (250, 500), (250, 500), (700, 600).

? Однако жадность работает в похожей задаче с делимыми объектами?

2) dp[i][c] - мин. вес предметов среди первых i, стоимостью c.
Time = _O_(n * SumCost), Память _O_(n * SumCost)

// Замечание - здесь(имея в виду 2D-табличный способ) можно порядок пересчёта сделать и по возрастанию

Научимся находить предка. 
p[i][c] = 0, если не взяли i-ого чёрта
p[i][c] = 1, иначе

Научимся экономить память - O(W). На самом деле можно можно хранить только последний уровень.
Только теперь нужно порядок пересчёта изменить на противоположный.

Решение задач с помощью бинарн. возвед. матриц.
Пример1: Поиск n-ого числа фиббоначи.
Идея (Fn+1, Fn) выразим через (Fn, Fn-1)
dp[i][0] = dp[i-1][0] + dp[i-1][1]
dp[i][1] = dp[i-1][0]
Заметим что операция равносильна умножению на нек. квадр. матрицу.
Их можно перемножать и возв. в степень быстро.

Пример2: Поиск произв.рекуренты.
An+2 = 3An+1 - 4An + 1
Решение: встроим в верт. столбец единицу и два послед. члена.

Пример: Число путей в графе из i -> j, длинной k.
Решение: возьмём и возведем в k-вую степени матрицу M - смежности графа и возьмём (i,j) клетку.
Док-во: индукция по длине k.
	База: очев.
	Переход: пусть верно для всех n < k. Док-ем для k.
(M^k)_i_j = (M^k-1 * M)_i_j = Summ(k = 1..n, (M^k-1)_i_k * M_k_j) - и это правда.
Мы могли прийти из k, только если есть путь из k в j, что обозначено умножением на M_k_j.

Пример: Число путей в графе длины <= k.
Решение: M + M^2 + ... + M^k
С помощью: рекурсивная реализация, с return {A^k, A^k + ... + A^1};


