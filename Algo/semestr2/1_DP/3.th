ДП по маскам
Можно составить биекцию между подмножествами множества U = {0, ..., n-1} и числами от 0 до (2^n - 1)
A / B <-> (maskA | maskB) ^ maskB


Поиск самого дешёвого гамильтонова пути.
dp[v][mask] = длина минимального пути, такого, что мы в v, и посетили mask вершин.
База dp[v][2^v] = 1, for v
else dp[i][j] = inf;

Пересчёт
for mask = 1...2^n - 1
	for from = 0...n - 1
		for to = 0...n - 1
			if(mask & (1 << to)) continue
			int newmask = mask & (1 << to);
			dp[newmask] = std::max(dp[newmask][to], dp[mask][from] + cost[from][to];
Ans = std::max(dp[2^n - 1][for i])

Упр. Граф невзвеш. и не обяз. полный. За О(2^n n) определить, есть ли в нём гамильтонов путь.
	Идея dp[mask] = submask, mask1 = множество вершин, где может заканчиваться путь, посещающий mask


Задача - поиск макс клики в графе.
	Пути решения:
	1) Перебор всех подмножеств и проверка на клику. 2^n * n^2
	2) bool dp[mask] - является ли множество кликой.
		Пересчёт - вытащить из маски что-то одно и проверить что dp[submask] = true, и v соед. с submask
		2^n * n
	3) Оптимизация (2) -> 2^n.
		Оптимизация1 - вместо произвольной вершины из mask - будем брать старший.
			Как? - Учитывая что мы перебираем маски по возрастанию - то можно поддерживать старший бит)
			Лектор: if(mask&(mask-1)) ++oldest; //100000 & 01111 = 00000
		Оптимизация2 - чтобы проверить, что v соед. с submask:
			1) Сперва сопоставим каждой вершине маску из соседей - mask_friends
			2) Чтобы проверить v соед с submask: (submask == mask_friends & submask)
	4) O(2^(n/2) * n) - подход meet in the middle
		Разделим вершины на две группы и занумеруем их в каждой половине 0...n/2
	1. dp1[mask] - маска вершин правой доли, кот. соед. со всеми из mask(из левой доли)
	dp1[empty_set] - вся правая доля
	dp1[mask | (1 << v)] = dp1[mask] & neigh[v]
		
	2. Осталось найти для любой mask из правой доли(явл. кликой) наиб. submask  явл. кликой. Пусть max(msk)
	Пусть a(V) = {|V| if V-клика else 0}
	Тогда max(mask) = max(for sub: a(sub)).
	Пусть dp[k][mask] = max(for V in mask, and старшие k bits of V same as mask, a(V))
	Пусть N - кол-во вершин в правой доле.
	База: dp[n][mask] = a(mask)
	Переход: dp[i][..] from dp[i + 1][..]
	if(bit(mask, N - i - 1) == 0)
		dp[i][mask] = dp[i + 1][mask]
	else
		dp[i][mask] = max(dp[i + 1][mask], dp[i + 1][mask ^ (2^(N-i-1))]);
	
	Таким образом общий алгоритм:
	1) Насчитываем dp1[mask] = подмножество справа, где нужно искать.
	2) Насчитываем dp[i][mask] = для поиска наибольшей подклики справа
	3) Перебираем все клики слева, для каждой смотрим в dp1[mask] и с помощью dp[i][mask] находим подклику

	Вопрос - зачем dp[i][mask]???
/*
Цель - получить младший бит.
mask     = 11101010000
mask - 1 = 11101001111
^        = 00000011111
+ 1	 = 00000100000
>> 1     = 00000010000
*/


ДП по профилю.

Задача.
Покрасить прямоугольник n * m в два цвета, так что нет одноцв. квадратика 2х2
dp[j][mask] - кол-во хороших раскрасок первых j столбцов, т.ч. j-ый покрашен в mask.
База dp[1][mask] = 1, for each mask
Пересчёт:
for j = 1..m-1
	for mask = 0..2^n - 1
		for mask1 = 0..2^n - 1
			if(correct(mask, mask1))  dp[j+1][mask1] += dp[j][mask]
ans = sum(for mask: dp[n][mask])

Оптимизация: можно предподсчитать correct(mask, mask1) заранее. Тогда O(4^n * (n + m))
Оптимизация: если что - можно повернуть табличку в самом начале - swap(n, m).
Оптимизация: возвед. матрицы в степень. Столбец dp[j + 1] = mtx(матрица ok) * dp[j] - O(8^n * logm)

ДП по изломанному профилю.
dp[i][j][mask] - излом в (i, j), mask - важные клетки(height + 1)


