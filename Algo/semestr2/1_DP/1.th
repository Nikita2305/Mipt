DP - description
1) what is dp[params]?
2) переход
3) начальные значения
4) порядок
5) где ответ

Задача о кузнечике. - одномерное ДП с прыжками на +1 и +2 с собиранием монеток с отрицательными числами too.

Задача о черепашке - поиск пути минимальной стоимости из (1,1) в (n,m).
	Динамика назад - обновление dp[i][j] из dp[i-1][j] and dp[i][j-1]
	Динамика вперед - обновление dp[i+1][j] and dp[i][j+1] из dp[i][j]

Задача поиска НОП двух послед.
dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
if(s1[i] == s2[j]) dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1);

Задача поиска НВП
1) за n^2. Possible - nlogn
dp[i] - максимальная последовательность, заканчивающаяся в i-м
Поиск dp[i] через dp[j], where j < i, and a[j] < a[i]
Заметим можно посортить {a[i], i}. И именно в таком порядке пересчитывать ДП.
Тогда достаточно брать максимум на префиксе dp[1...i-1] и обновлять с его помощью dp[i].
В этом нам поможет ДО на максимум(не забываем обновлять в точке).

2) за nlogn
dp[i] - наименьший последний член НВП длины i
Очев. dp - возрастающий массив. Тогда поиск dp[i] через бинпоиск по dp.

Лектор(плавно):
dp[i][k] - наим. значение последнего элемента в ВП длины k среди a1..ai

dp[i][k] = (dp[i-1][k] or a[i]). Т.к. мы добавили в массив рассматриваемых только ai.
Итерируясь по i(добавляя постепенно ai в набор рассм.) заметим,
что на каждом шаге мы меняем не более одного значения в dp.
Положим k = min index, where dp[i-1][k] > a[i]. 
* Легко видеть что слева все числа <= a[i]. Их по определению глупо обновлять.
* Справа же все числа > a[i], их обновлять невозможно, и вот почему.
Пусть мы можем обновить какое-то число a[j], j > k.
Тогда существует последовательность длины j, кончающаяся на a[i]
Но тогда на префиксе [0..j-1] есть последовательность длины j - 1, 
с последним членом меньше a[i]!
Но вот беда, j > k => (j - 1 >= k) => dp[j-1] > a[i]
А значит у любой последовательности длины j-1 последний член > a[i]
