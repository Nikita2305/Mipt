B - дерево.
У В-дерева есть нек. параметр t.

Тогда в некорневой вершине лежит посорченный массив из q = t-1 .. 2t-1 чисел
В корне q = 1 .. 2t-1
Из каждой вершины выходят q + 1 сыновей, по аналогии с бинарным деревом.
Все листья находятся на одинаковой глубине.

Зачем это нужно? Чтобы уменьшить высоту, а значит количество переходов по указателям.
В больших БД, хранящихся на жёстких дисках

Теорема: Если в дереве n ключей, то его глубина есть _O_(log(t,n))
Сконструируем дерево высоты h, с наим. кол-вом вершин.
1 + 2(t-1) + 2t(t-1) + ... + 2t^(h-1)*(t-1) = 1 + 2(t-1)(1 + t + ... + t^(h-1)) = 1 + 2(t-1)(t^h - 1)/(t-1) = n
t^h = (n + 1)/2
а значит h <= c*log(n,t), h = _O_(log(t,n))

Операции:
find x - очев.

insert x - Найдём лист(как и всегда) и вставим туда x. Если вставить невозможно(size(list)) = 2t-1
Решение такой проблемы - перед тем как идти в сына - проверим, что там не 2t-1 вершина. Если это так,
то вытаскиваем из него середину, пихаем в себя, слева и справа от себя впихиваем указатели на левый и правый куски
массива сына. Спуск верху вниз, так что победа(разбиваем любой возможный)

erase x - Найдём лист и удалим оттуда x. Аналогично спускаясь вниз будем поддерживать, то что в каждой вершине >=t,
если это не корень
Пусть мы в нек. вершине и в ней t-1 штука. рассмотрим правого брата. Если в нём >=t, то из него пихнём в
родителя-разделителя, а оттуда к нам скраешку справа. 
Если же в нём t-1, то мы можем смёрджить двух братьев, спиздив сверху одну штуку(по индукции там >=t)
Теперь в объединённом >=t, но <=2t-1.

Супер, когда мы придём в нужную вершину, там будет >=t вершин.
Если в левом или правом сыне x: >=t вершин, то можно спиздив минимум.максимум вставить его вместо нас.
Если и там и там t-1, то склеим их, ёбнем x, вставим вместо этого всего склееную штуку
