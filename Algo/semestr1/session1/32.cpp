Амортизационный анализ.
Если для любого n и любой последовательностии из n запросов суммарное время их обработки есть sum(Ti(n))
то можно считать, что учётное(амортизационное) время работы i-го запроса - Ti(n)
Зачастую подразумеваются какие-то очевидности.

Метод монеток/бухгалтерского учёта.
Каждая операция имеет некоторое Ti - время операции.
Далее каждой операции мы сопоставим два числа:
Di - количество монеток, которое она вносит
Wi - количество монеток, которое она тратит

Утв. Сумм(Ti) <= Сумм(Ti + Di - Wi), т.к. на любом префиксе мы требуем, чтобы на депозите было больше 0

Общая идея - обозначим число Ai = Ti + Di - Wi. Подберём Di и Wi так чтобы Ai оценивалось просто(напр: константа)

Вектор - пример применения.
1) Очевидности
Каждому расширению капасити с -> 2c предшествовало по крайней мере c/2 push_back - ов.
На расширение капасити с -> 2c необходимо не более 2с операций.
Тогда сопоставим каждому push_back - 5 операций. 4 за будущее расширение, 1 за себя

Каждому сужению капасити с -> c/2 предшествовало по крайней мере с/4 pop_back
На сужение капасити с->c/2 необходимо не более с операций
Тогда сопоставим каждому pop_back - 5 операций. 4 за будущее сужение, 1 за себя

Тогда можно сказать, что всего выполнится не более 5n операций. Т.е. О(n)

2) Монетки
Пуш бэк - кладём 2 монетки, t = 1, d = 2, w = 0 - на себя и на парня назад
Поп бэк - кладём 2 монетки t = 1, d = 1, w = 0 - на парня назад дважды
Capacity change x/2 -> x: t = x/2, d = 0, w = x/2 - снимаем монетки со всех ребят
Capacity change 2x -> x: t = x, d = 0, w = x - снимаем монетки со всех ребят(по 2 штуки)
