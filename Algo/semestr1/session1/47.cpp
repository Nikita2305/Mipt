Splay Tree

zig/zag/zig-zag/zig-zig - left and right rotations
splay(x) - move x to the root

Find x - find + splay(x)
Insert x - insert + splay(x)
Erase x - erase + splay(minOnTree(x->r)->r) //самая глубокая посещённая

Т.е. хотим ограничить сверху время любой операции - временем операции splay. Покажем, что он работает за O(log(n))*

Метод потенциалов. 
Введём Ф(S) - функция от состояния структуры S
Фi - потенциал структуры после осущствления первых i операций.
Пусть Ti - реальное время работы i-й операции 
тогда амортизационное Ai = Ti + Фi - Ф(i-1)

Достаточно выбрать Фk >= Ф0, чтобы на любом префиксе сумм(Ai) >= сумм(Фi)
//Полагая Ф0 = 0, значит необходимо Фk >= 0.

Теорема: Амортизированное время работы операции splay есть O(log(n))
S(x) - кол-во эл-ов в поддереве x.
r(x) = log(S(x))
Ф = сумм(v-верш, r(v)) - докажем что этот потенциал доказывает задачу.

После i-го splay(x) (докажем далее)
a(i) <= 1 + 3*(r'(x) - r(x)) <= 1 + 3log(n), где r'(x) - ранг x в новом дереве

//единица тут обозначает малый поворот
a(zig) = 1 + r'(x) + r'(p) - r(x) - r(p) <= 1 + 2(r'(x) - r(x)) <= 1 + 3(r'(x) - r(x))
a(zag) = a(zig) <= 1 + 3(r'(x) - r(x))
a(zig-zig) = 2 + r'(x) + r'(p) + r'(g) - r(x) - r(p) - r(g) <= 2 + r'(x) + r'(g) -r(x) - r(x)  <?= 3(r'(x)-r(x))
Покажем, что r(x) - r'(x) + r'(g) - r'(x) <= -2
Легко видеть, что и то и то log(part/size). Всилу того, что part не пересекаются (AB и CD соотв.), то 
a + b <= 1. А значит sqrt(ab) <= (a+b)/2 <= 1/2, ab <= 1/4. log(ab) <= -2.
a(zig-zag) - аналогично.

А значит, рассматривая splay как комбинацию zig, zag... - получим a(splay) <= 1 + 3(r''(x) - r(x))
(Произойдут телескопические сокращения всех промежуточных рангов)

И лекго видеть, что a(splay) <= 1 + 3log(n), т.к. r'(x) <= log(n)

