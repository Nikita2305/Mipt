Хэш - таблицы.
Хотим построить map. Проблема для чисел - ключи могут быть слишком большие.
Тогда давайте создадим функцию, которая отобразит наше множество чисел в меньшее множество.
h: U -> Zm, хэш-функция.
Ну и тогда чтобы получить значение по х -> arr[h(x)];

Коллизия - когда h(x) = h(y), но x != y. Это неизбежно, но есть способы исправить.
1) Разрешение с помощью цепочек:
	Хотим положить что-то по h(x). Там ничего нет -> кладём.
		Там что-то есть -> кладём наш {x, val} и привязываем цепочку того что есть к x
	Хотим что-то взять по h(x).
		Приходим в arr[h(x)] и идём по цепочке пока не найдём .first = x
	Цепочка - связный список(std::list)
Время работы оценивается длинной цепочки.

Simple Uniform Hashing. Zm^U - есть множество всех отображений из U в Zm.
При SUH берём случайную из них. А значит равномерно выбираем для каждого числа x = 0...|U|-1 значение h(x).

Посчитаем мат. ожидание длины цепочки. Пусть Ci - цепочка из элементов x, т.ч. h(x) = i;
Пусть в таблице n элементов: x1..xn
E(|Ci|) = E(sum(j=1..n, h(xj) == i)) = sum(j=1...n, E(h(xj) == i)) = sum(j=1...n, 1/m) = n/m = alpha - load factor
load factor - характеристика загруженности
Тогда Запрос обращения = O(alpha)
Если хотим O(1)*, то будем поддерживать alpha < 95%. Как только alpha > 95%,
то увеличиваем m -> 2m и меняем хэш функцию
И раскидываем существующие в мэпе элементы по новому массиву. Доказательство О(1)* аналогично вектору.

Ок. Что нам осталось? Осталось научиться выбирать случайную хэш функцию из U -> Zm

----Среднее мат. ожидание выполнения успешной операции.
Операции бывают:
успешные - вставка, поиск существующего, удаление существующего - они не ходят по всей цепочке
неуспешные - удаление несуществующего, поиск несуществующего - они ходят по всей цепочке.
Докажем, что среднее мат ожидание успешной - O(1 + alpha). Пусть добавили n элементов посл-но: x1 .. xn
Введём аналог символа Кронекера - xij = (h(xi) == h(xj))
Поиск xi работает за Sum(j=i..n, xij)
Среднее матожидание по всем xi: 1/n * sum(i=1..n, E(sum(j=i..n, xij))) = 
= 1/n * sum(i=1..n, E(sum(j=i+1..n, xij)) + 1) = 1 + 1/n * sum(i=1..n, sum(j=i+1..n, E(xij))) =
= 1 + 1/n * sum(i=1..n, sum(j=i+1..n, 1/m)) = 1 + 1/n * sum(i=1..n, n-i/m) = 1 + 1/nm * sum(i=1..n, n-i) = 
= 1 + 1/nm * sum(i=0..n-1, i) = 1 + 1/nm * n(n-1)/2 = 1 + (n-1)/2m = O(1 + alpha)

Universal Hashing - семейство H хеш-функций из Zm^U универсально, если для любых x!=y из U,
верно P(h(x)==h(y)) <= 1/m - это есть условие сильной универсальности для множества H.
Вероятность P берётся по всем h из H.
Какое-то там упражнение?

Пример универсального семейства.
H_p = {h_k,b | h(x) = ((kx + b) mod p) mod m}, p - простое, > m
Теперь функция из семейства Hp задаётся двумя числами k = 1..p-1, b = 0..p-1
Докажем, что это семейство действительно универсально.
Рассмотрим произвольные x!=y. Рассмотрим по всем h: P(h(x)==h(y))
Заметим kx + b != ky + b (mod p), т.к. k(x-y) != 0 (mod p), т.е. на первом уровне нет коллизий.
? Утв. для любых k, b существует биекция между {(x,y)} и {((kx + b) mod p, (ky + b) mod p)}
Утв. для любых x!=y, u!=v : существуют k,b, т.ч. kx + b = u, ky + b = v. 
Записывая систему:
(x 1) (k) = (u)
(y 1) (b) = (v)
Заметим, что определитель основной матрицы = x - y != 0, а значит система имеет решение, причём единственное
Тогда P_k,b(h(x) == h(y)) = P_u,v(u mod M == v mod M) <= 1/M, а значит семейство универсально

Совершенное хэширование - способ достичь O(1) честно. Пусть есть Build(key1..keyn) и Find(x)
Будет два уровня хэширования. Сначала x -> h(x). Попадаем в какую-то клеточку табличкт.
Оттуда по своей конкретной хэш фукнции пиздошим иx -> hi(x).
Суть build - подобрать сначала h(x), а затем много функций hi(x).

...(with no proof)

Хештаблицы с открытым ключом.
Получаем x -> пихаем в h(x)
Получаем y -> пихаем в h(y). Если там занято, то идём вправо и вставляем, когда свободно.
Получаем z -> пихаем в h(z). Аналогично.
Пусть .. x, y, z ..
Если хотим удалить - find + хуярим туда tombstone.
find: Идём вправо до первого пустого(tombstone - могильный камень).
insert: find + first_tombstone

Что касается поиска камня:
1) линейное пробирование - как мы только что делали. runi = (h(x) + i) % m
	2 - независимое семейство => O(sqrt(n))
	3 - независимое семейство => O(log(n))
	5 - независимое семейство => O(1)
2) квадратичное пробирование.runi = (h(x) + i^2) % m;
3) двойное хеширование. runi = (h1(x) + i*h2(x)) % m;
	Если h1 и h2 - из 2 - независимого семейства => O(1)
Т.е. runi: будем ходить по ячейкам с номерами h(x) + .. в поисках нашего.

K - назависимое семейство хеш-функций.
Для любых x1!=x2!=...!=xk следующие величины независимы в совокупности: h(x1)...h(xk)
- т.е. фиксируя h(x1)..h(xk-1) __ h(xk) может принимать любые значения
Для любого k существует k-независимое семейство


Фильтр Блума.
Хочется уметь:
Insert
Find(x)
	1) x лежит - фильтр всегда работает
	2) x не лежит - можно сказать "лежит", но с маленькой вероятностью
Идея: есть приложение и БД
Приложение обращается к Фильтру на find. Получает ответ нет -> его в БД правда нет. Получает ответ Да - идет честно.

Тогда фильтр сопоставляет x -> (h1(x), h2(x) ... hk(x)) И ставит в хэш таблице[0..m-1] единицы туда
И find - смотрит на h1(x) ... hk(x). Если там нет всех единиц -> x нет
Если там есть единицы -> x есть или False-Positive.

n ключей, m - размер таблицы, k - размер фильтра.
Оптимальный k при фикс n, m.
	k минимизирует FPR = (1 - (1 - 1/m)^kn)^k - вероятность того, что k независимых случайных бит равны 1.
	k = m / n * ln(2), (m > n).
Оптимальные k и m, при фикс. n и FPR:
	m = -n ln(FPR) / (ln2)^2
	k = -log2(FPR)



