Куча Фибоначчи:
insert - O(1)
merge - O(1)
getMin - O(1)
decreaseKey - O(1)*
extractMin - O(logn)*

Куча Фибоначчи - множество деревьев, удовл. свойству кучи.
Пусть корни всех деревьев хранятся в нек. списке. Достаточно поддерживать указатели на first и last
merge - просто прикрепить указатель от одной кучи к другой
insert - добавить в другую кучу точку и merge куч
getMin - всегда будем поддерживать указатель на минимальный корень
extractMin - вытащить один из корней и с-merge-ить кучу детей и кучу остальных деревьев. + consolidate

Сперва определим степень вершины, как количество сыновей.
Тогда степень [корня] дерева определяется как степень этой вершины.
Можно объединять 2 деревa степени k -> дерево степени k + 1, просто подвесив одно к другому

Определим consolidate - причёсывание кучи. 
Идея причёсывания - идём по корням по очереди и добавляем в массив newRoots(0..D(n)) - объединяем, если нужно
where D(n) - наибольшая степень в дереве размера n

Откуда амортизированный log?
На каждом корне - монетка.
На каждой помеч. вершине(нек. поле mark = true) - по две монетки.
Совершая extract - нужно на каждого сына положить по монетке. А значит всего <=D(n) монеток.
Совершая merge деревьев - траьтим монетку с одного из деревьев

Вообще время работы extractMin ~ количество сливаний дерева ~ количество снятых монеток. Бужем считать t = w
Ну тогда a = d + (t - w) = d <= D(n) ~ log(n) -- интуиция.

Интересный факт - до этого момента это биномин. куча, у которой ушло причёсывание с merge
и остался аморт. log(n) в extractMin

----
Перейдём к decreaseKey. 
node.mark = true, если у этой вершины вырезан РОВНО один сын.
Как уже ранее было оговорено, на каждый node(node.mark = true) кладём 2 монетки

Будем поддерживать такой инвариант - у каждой вершины отрезано не более одного сына.
Так вот - если мы хотим уменьшить некоторую вершину, то мы вырезам это поддерево и вставляем в список деревьев
Если у её родителя - mark = true, то мы и его вырезаем и т.п. пока не дойдём до корня или не сохраним инвариант
Асимпотика - О(1)*, т.к. при каждом вырезе и выносе поддерева в кучу - одна монетка остаётся на корне,
а второй расплачиваемся за операцию переноса указателей
// Т.е. вытаскиваем тогда, когда у вершины вырезается второй ребёнок.


Ну и иногда там кладём монетки, чтобы сохранять все инварианты по монеткам.

P.S. не забываем поддерживать minPtr
----
Что касается D(n) - наибольшая степень дерева размера n.

Для этого сперва посчитаем S(k) - минимальное количество элементов в дереве со степенью корня k.
Упорядочим(пронумеруем) детей корня в порядке их присоеджинения к корню: u0 .. u(k-1)
В момент, когда ui подвешивалось к V, у ui степень была хотя бы i.
(Рассуждения из того, что в тот момент и у V степень была хотя бы i(могут быть те, кого бы удалили и их нет в {U}))

Сейчас у ui степень хотя бы i-1.
Sons degrees:
	Было: >=0, >=1, ... >=k-1
	Стало: >=0, >=0, ... >=k-2, Откуда S(k) >= 2 + Sum(i=0..k-2, S(i)). где 2 - корень и левый сын.

S(0) = 1, S(2) = 2.
Положим S(k) = 2 + Sum(i=1..k-2, S(i)), т.е. будем искать нижнюю оценку на количество вершин
Докажем, что S(k) = F(k+1) число фибоначчи. База: S(1) = F(2) = 1. S(2) = F(3) = 2 - yess
Переход. S(k) = 2 + F(2) + ... + F(k-1) = S(k-1) + F(k-1) = F(k-1) + F(k) = F(k+1), ч.т.д.

F(n) = [((1+sq(5))/2)^n - ((1-sq(5))/2)^n] / sq(5) - Доказать по индукции, полагая F(1) = F(2) = 1.
F(n) = O(phi^n), where phi = (1+sq(5))/2
А значит S(k) = F(k-1) = O(phi^(k+1) = O(phi^k)
А значит обратная функция D(n) = O(log(phi, n)) = O(log(n)), т.к. логарифмы отличаются на константу.

Недостаток - большая константа, которая по итогу не даёт большего выгрыша на практике
(несмотря на меньш. асимптотику merge) при небольших n(<=10^9). В ином случае конечно победа:)
