



Сортировка

Интересный факт: log(n!) = O(n*log(n))
1) log(n!) = log1 + ... + log(n) <= n*log(n)  ---> log(n!) = _O_(n*log(n)
2) log(n!) >= n/2 log(n/2) = n/2 (log(n) - log(2)) = n/2 log(n) - n/2. ---> log(n!) =  W(n log(n))

Докажем теперь что для сортировки потребуется W(nlogn) сравнений.
Заметим что из массива {a1..an} существует n! перестановок. Пусть мы сделали x вопросов.
Тогда мы можем детерминировать 2^x перестановок, т.е. 2^x>=n!, откуда x >= log(n!) = W(nlog(n))
Откуда x = W(nlog(n))

Найдём сортировку, работающую за _O_(nlogn).// Пример - mergesort
//T(n) = 2*T(n/2) + O(n)
Откуда время работы mergesort = O(nlogn)

Поиск количества инверсий - осуществляется с помощью mergesort!

Рассмотрим quick sort.
Рассмотрим процедуру Partition(v,x), которая 
первыми t элементами ставит числа <x
вторыми n-t элементами ставит >=x
X - называется pivot - разделитель.


Идея: sort(1..n): Partition(v(1..n),X), sort(v(1..t)), sort(v(t+1..n))
Поскольку можно очень неудачно выбирать X, делая это совершенно рандомно
Будем брать в качестве X некоторый элемент массива, т.е. X = v[rand]

Таким образом:
Qsort(A){
	a.size() == 1 -> return
	x = rand(A)
	{B,C} = Partition(A,x)
	Qsort(B)
	Qsort(C)
}

Теорема - Матожидание времени работы есть _O_(nlogn)
Док-во:
	L1: 1/1 + 1/2 + 1/3 + 1/4 + ... + 1/n = O(logn)
	Док. L1:
	1) пусть k такое максимальное что, 2^k <= n, k = log(n)
	S >= 1/1 + 1/2 + ... + 1/2^k >= 1/1 + (1/2) + (1/3 + 1/4) + (1/5 + 1/6 + 1/7 + 1/8) + () ...
	//Заметим что в каждой скобке сумма >= 1/2. Доказывается как угодно(индукция/огрубление в каждой скобке)
	Заметим, что слагаемых 2^k = 1 + 1 + 2 + 4 + ... + 2^(k-1)
	т.е. скобок всего k. Откуда S >= 1 + k/2 >= 1/2log(n)
	// Оценка снизу доказана
	2) Пусть k минимальное такое, чтобы 2^k-1>=n
	S <= 1/1 + 1/2 + ... + 1/(2^k-1) = 1/1 + (1/2+1/3) + (1/4+1/5+1/6+1/7) + () + ...
	//Заметим, что в каждой скобке сумма <= 1
	Заметим, что слагаемых 2^k - 1 = 1 + 2 + 4 + ... + 2^(k-1)
	т.е. скобок всего k. откуда S <= k <= log(n)
	
	Обозначим через D = массив A после сортировки. 
	D1 <= D2 <= .. <= Dn
	
	С какой вероятностью Di и Dj когда либо сравнятся? Где i < j
	Утверждается, что с матожиданием E(i,j) = 2/(j-i+1);
	Тогда E(сравнений) = Сумма по всем возможным i,j: E(i,j) = 
	= Сумма по k = 2..n : 1/k*(n-k+1) <= n*(Сумма по всем k = 2..n : 1/k) = n*log(n)

	
