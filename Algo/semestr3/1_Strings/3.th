Суфф. массив.

1) 
Пусть s = s0s1...s_n-1
let s^i = s_i,s_i+1,...,s_n-1 // суффикс
Опр. Суффиксный массив строки s - перестановка чисел от 0 до n-1: p0,p1,...,p_n-1
Такая, что s^p0 < s^p1 <  ... < s^p_n-1

2)
Опр. LCP(s, t) - longest common prefix
Массив LCP - набор чисел lcp_0, ..., lcp_n-2
Такое, что lcp_i = LCP(s^p_i, s^p_i+1)

3) Sparse_table на массиве LCP.

----

Утверждение:
let p_l = i, p_r = j, l < r
Тогда LCP(s^i, s^j) = min{lcp_k, k in [l, r-1]}

Докажем его:
Пусть min{lcp_k, k in [l, r-1]} = x
Очев, LCP(s^i, s^j) >= x, т.к. первые x символов во всех строках совпадают
Пусть оно > x, тогда поскольку суфмасс отсортирован по возрастанию, то все префиксы длиной x + 1 совпадают,
откуда противоречие с тем, что min{lcp_k, k in [l, r - 1]} = x

Ну в общем теперь за О(1) умеем искать LCP двух суффиксов (потому что построена min sparse table на массиве LCP)

Простое применение:
Равенство подстрок. Просто берём соотв. суффиксы, находим их LCP и если он > len(s_1), то победа.

Приступим к реализации 1) и 2).

1) Алгоритм построения суфф. массива
Положим s = s + '#', где # - символ, меньший чем все существующие
Утверждение: сравнивать суффиксы старой s(без #) и сравнивать циклические сдвиги новой s(с #) - одно и то же
    // Единственное различие - в новой интерпретации добавл. в самое начало цикл. сдвиг '# + s'

На k-м шаге получим сортировку всех цикл. подстрок длины 2^k, а также их разб. по классам эквив.
Классом эквив. мы называем множество равных строк (которые в сортировке идут подряд)

Пусть p_i - начальный индекс подстроки длины 2^k, идущей i-й в порядке сортировки
c_i - номер класса эквив подстроки si,s_i+1, .. s_i+2^k-1 

* Чтобы определить p_i и c_i при k = 0 (len = 1), то отсортируем символы стабильной сорт. подсчётом (p_i посч.),
а в конце посчитаем c-шки

* Пусть известны {p_i} и {c_i} на k-й итерации.
Тогда |s| = 2^k+1 => s = a + b, |a| = |b| = 2^k.
С помощью {c_i} можно за О(1) сравнивать левые и правые части.
Короче чтобы отсортировать строки - отсортируем соотв. пары. Это можно за О(n)
Как? Сначала по второй компоненте пары, а затем стабильно по первой. Дважды подсчётом и стабильно по итогу за О(n)
Таким образом p-шки посчитаны, а чтобы посчитать c-шки, то просто с помощью старых c_i,
    сравнивая префикс и суффикс в отсорченном порядке находим новые {c_i}

Таким образом за O(n logn) мы можем отсортировать цикл. подстроки длины 2^k > n, k - минимальное такое
Утверждение: это то же самое, что и отсортировать строки длиной n.

2) Алгоритм подсчёта lcp
let pos_i = j, если p_j = i, т.е. если суффикс начин. в i стоит на j-й позиции.
Затем найдём lcp_pos0 наивно (т.е. lcp самой длинной строки и следующей за ней.)
После того обрежем первый символ от обеих строк.
У нас получится две новых строчки, одна из которых на pos1 в суффмасе, а другая (очев.) позже неё в суфмасе
Намишем код короче.
l = 0;
for w = 0..n-1 {
    i = pos[w]
    if (i == n - 1) {
        l = 0;
        continue;
    }
    v = p[i + 1]
    l = max(l - 1, 0) // нижняя оценка на новый l
    while (w + l < n && v + l < n && s[w + l] = s[v + l])
        l++;
    lcp[i] = l
}
Осталось показать, что l падает не более чем на 1.
Поскольку (стр. 64), то в суффмасе у всех строк (между 2мя новыми) есть общий префикс l-1, а значит lcp >= l-1.
Асимптотика линейная О(n) смотря на l.

Этот алгоритм(2) называется Касаи.
