Суфф. автомат
Работа происходит с конечными детерменированными автоматами(уже давно, вроде).
Определение принимаемого слова и L(A) - языка, задаваемого автоматом.

Нашей целью будет - по строке S построить минимальный ДКА А, такой что, L(A) - в точности все суффиксы S.
В том числе eps in L(A).
Замечание: минимальный = по числу вершин.

Опр. Пусть L - язык, x,y - слова.
R_L(x) = {z | xz in L} - правый контекст x относительно L.
Условно - правый контекст - это то, что гугл вам предлагает(сам суффикс), когда вы начинаете вписывать
x ~L y, если R_L(x) = R_L(y).
Классы эквивалентности будем обозначать, как [x]_L

Теорема (Майхилла-Нероуда)
Пусть L - язык, причём k = {forall x | [x]_L} - количество классов экв-ти конечно
Тогда 
    1) любой автомат А, принимающий L, содержит хотя бы k вершин
    2) есть автомат А, принимающий L, в котором ровно k вершин

Нам важен пункт 1), док-во очевидное:
    Пусть вершин меньше, тогда две строки из разных классов будут считаны в одно состояние,
            Но, противоречие, т.к. множество возможных суффиксов - одинаковое

-- Построим алгоритм, который докажет 2). --
R_L(not substring of S) = empty_set // такие строки не рассматриваем
Зафиксируем, что L - язык всех суффиксов

Утв. Пусть R_L(u) = R_L(v)
Тогда (u - суффикс v) or (v - суффикс u).
Док-во:
Существует w: uw in L, vw in L => uw, vw - суффиксы L => один из них - суффикс другого.

Утв. Пусть С - класс экв. относительно ~L.
Тогда C - это какая-то строка u и несколько её самых длинных суффиксов.
Замечание: в классе С лежат именно подстроки, а не суффиксы
Док-во:
Пусть u - самая длинная строка в С, тогда все остальные строки в С - её суффиксы.
Пусть v in C => докажем, что все более длинные суффиксы u лежат в С.
R_L(v) = R_L(u). Пусть w - более длинный суффикс u, чем v.
Тогда R_L(w) in R_L(v), т.к. v - суффикс w.
Ан-но R_L(u) in R_L(w), т.к. w - суффикс u.
Откуда R_L(v) = R_L(w) = R_L(u);

Опр.
Обозн. [x]_L, R_L <-> [x], R
// При фикс S.
longest(C) - самая длинная строка в C.
len(C) = |longest(C)|
link(C) - суффиксная ссылка класса С
link(C) = [x],  где x - самый длинный суффикс строки longest(C), который не лежит в С
Замечание: |C| = len(C) - len(link(C))

Утв. (Критерий longest).
Пусть u - подстрока s. 
Тогда u = longest([u]) <=> (u - префикс s) or (сущ. a != b, that au, bu - подстроки S)
Д-во.
1) Пусть u != longest([u]), тогда u ~ cu
R(u) = R(cu) => u and cu имеют одинак. множ-ва концов вхождений в S.
Тогда очев не верно ни (u - префикс s), ни (сущ. a != b, that au, bu - подстроки S)
2) Пусть u = longest([u]) and u - не префикс S.
Рассмотрим все вхождения u в S, а затем перейдём к символам перед вхождениями.
Пусть они все одинаковые и равны t, ну тогда R(tu) = R(u) -> u != longest(C), т.к. tu in C

Алгоритм построения суф. автомата
1) Инкрементальный подход.
2) Не следим за териманальностью (проставим в конце через прыжки по суфлинкам)

Пусть для строки S - построен суф. автомат
Затем приписываем символ c к S.
Хотим перестроить автомат.
Следить за классами экв-ти <=> следить за лонгестами.
Вопрос - как поменяется множество лонгестов?

Замечание: Если u была лонгестом, то u - останется лонгестом (см. Критерий)
Т.е. лишь могут появляться новые лонгесты.

Замечание:
В том числе: Sc - новый лонгест
Опишем класс [Sc]_Sc: множ-во всех суффиксов Sc, не являющихся подстроками S.
    Это правда, ведь R_Sc(Sc) = {eps}

Замечание:
Пусть T - какой-то ещё новый longest.
Тогда T - подстрока S, т.к. по пред. замечанию все неподстроки лежат в другом классе.
T - ранее не была лонгестом, а значит по критерию:
S:  |--xT--xT---|
Sc: |--xT--xT--yT|
Таким образом:
1) T - подстрока S
2) T - суффикс Sc
3) yT - не подстрока S

Вывод:
Единственный кандидат на роль T - максимальный суффикс Sc, являющийся подстрокой S.

Вывод:
Может прибавиться не более двух новых лонгестов (ака новых состояний).
Обозначим S0 - max суффикс Sc, явл-ся подстрокой S.
link([Sc]sc) = [S0]sc // по опр. линка

ВНИМЕНИЕ - переход к автоматам.
Утв. Пусть v - вершина автомата.
Рассмотрим все стрелки, которые в неё ведут(именно стрелки автомата). Тогда
1) На всех стрелках написана одна и та же буква
2) link(u_i) = u_i+1, forall i (именно линки)

Д-во:
    Замечание про автомат:
    Когда мы говорим строчки из класса v - имеем ввиду строки, которые автомат способен распознать,
    по итогу оказавшись в состоянии v.
    С(v) - есть объединение многих классов + letter, из вершин которых ведёт ребро с letter в вершину с.
Нарисуем все строчки, которые лежат в классе v:
|-----------| = longest(C)
 |----------|
  |---------|
   |--------|
Наблюдение 1: [eps] = {eps}, т.к. R(eps) = {все строки} и это будет корневая вершина.
Наблюдение 2: А значит у всех строк выше последний символ = c (т.к. все строки не пустые).
              А значит и символы на рёбрах автомата будут везде с, т.к. Замечание про автомат.
Наблюдение 3: Осталось заметить, что класс С разбивается на неск. последовательных групп,
              каждая из которых пришла из некоторой вершины u_i, приписыванием c,
              а значит, легко понять, что link(u_i) = u_i+1 
                // Ещё бы, ведь в u_i-1 лежат суффиксы u_i и более того последоавтельно

Инсайт:
Рассмотрим класс Sc // свежедобавленная вершина
Есть ребро S --(c)--> Sc
А затем путешествуем по link(S) и добавляем ребро link(S) ---(c)---> Sc
