Суфф. дерево

Опр. Дана строка S, S' = S + '$'
Тогда суфф. дерево - это сжатый бор, построенный на множестве всех суффиксов строки S'.

Замечание:
Про сжатость: из одной вершины не может исходить неск. рёбер, начин. с одной буквы (иначе выделим в отдельную вер.)

Замечание:
На любом ребре написана подстрока - можно хранить, как l, r;

Утв. В суфф. дереве строки длины n - всего О(n) вершин.
Д-во.
Чтобы это доказать - построим простейший алгоритм построения суфф. дерева за n^2
1) Добавим всю строку в терминах сжатого бора
    Бор имеет вид - root -----> leaf1
2) Добавим s^1 - суффикс длины n - 1.
    Тогда либо 
    root -----> leaf1
    root -----> leaf2
    либо
    root -----> node ------> leaf1
                node ------> leaf2
    Добавилось не более 2 вершин
3) Ан-но при добавлении новых суффиксов - будет добавляться не более чем по две вершины.

Откуда имеем О(n) памяти, откуда есть надежда на О(n) времени.

Позиции в дереве
1) Вершины
2) В рёбрах
    Чтобы задать: родительская вершина, первая буква ребра, число прочитанных символов

Суффиксная ссылка 
    Опр: самый длинный собств. суффикс, который есть в боре
Для суфф. дерева суфлинк - указатель на позицию в дереве, получаемую отбрасыванием первого символа

Утв. Суфф. ссылка вершины - вершина (для полного суфдерева(или нет??)).
Д-во.
Вершины - листья и не листья.
1) Листья - в точности все суффиксы, т.к. ласт символ $ 
    Суфф. ссылка от листа - лист. (Т.к. суффссылка суффикса - суффикс)
2) Не листья - есть >= два сына (иначе сжали бы), а значит в строке есть alpha + 'a', alpha + 'b' (пример в лекции)
    |-----alpha------|
     |-----beta------| - суффикс, который лежит в дереве, как префикс суффикса
    Но поскольку в строке есть alpha + 'a', alpha + 'b', то там есть beta + 'a', beta + 'b'
    А значит beta - тоже вершина (не в ребре).

Сразу опишем getLink - найти суффссылку для произв. позиции в дереве.
Считаем, что все суфф. ссылки для вершин посчитаны.
Т.е. имеем node, char, len - вершина, буква, длина в ребре (Пусть ребро [l, r])
1) node != root
    => suflink(node, char, len) = suflink(node) + [l, l + k - 1]
                                                // Тут может быть несколько рёбер
2) node == root
    => suflink(root, char, len) = root + [l + 1, l + k - 1]

----- Алгоритм Укконена - построение суфдерева за O(n) -----

Пусть дерево построено для первых k символов и пришёл c - новый символ.
Утв.
На этом этапе суффиксы делятся на 3 типа.
1) Листья - несколько самых длинных
2) Не листья, из которых нет перехода по с - следующие неск. самых длинных
3) Не листья, из которых есть переход по с - оставшиеся самые короткие

Д-во.
Важное замечание: на этапе не до конца построенного дерева (нет $), неверно, что суффикс = лист
1)
Рассмотрим самый короткий суффикс, который явл. листом. Значит вершина без ветвления
Тогда все более длинные суффиксы - тоже листы. Потому что эти вершины без ветвлений (иначе рассуждения как alpha, beta)
3)
Рассмотрим самый длинный суффикс, из пункта 3
Тогда по alpha/beta рассуждениям для любого более короткого суффикса - есть переход по с.
2)
Доказывается автоматически.

Чтож - теперь нужно к каждому суффиксу добавить букву с (опционально добавить ребро и сдвинуть терминальность).
Замечание1: Листья из утв. останутся листьями. (пункт 1, утв.)
    Т.е. как только получили на нек. этапе лист - сразу дописываем ребро до конца строки.
    Более эта вершина не учитывается в обработках.
Замечание2: Про вершины пункта 2, утв.
    В случае, если суффикс оканч. в ребре - расщепляем ребро - добавляем новый переход.
    В случае, если суффикс оканч. в вершина - просто добавляем ребро и вершину.
    Вершина станет листовой! // А значит можно сразу дописывать до конца
    * Интересно, что чтобы хранить эту категорию - достаточно хранить только наидлиннейший суффикс оттуда,
    * а чтобы перебирать суффиксы - брать суфлинки.
Замечание3: Про вершины пункта 3, утв.
    Тут нужно просто снести терминальность вниз.

Напишем код:
cur = s // означает самый длинный суффикс из второй группы
for c in s:
    while (из cur нет перехода по с):
        создать переход из curr: [c, $]
        cur = getLink(curr)
    cur = curr->to[c]
Замечание:
Чтобы пометить терминальные вершины - в конце проставляем терминалы, как многократное применение suflink к s
При создании новых вершин - подсчитываем линк для неё.

Асимптотика:
    while - суммарно делает O(n) операций, т.к. он двигает итератор вперёд
    Последнне что осталось - понимание работы getLink(node). Согласно выкладкам ниже суммарно не более O(n)
    Откуда имеем асимптотику O(n)
Выкладки:
Пусть depth(v) - кол-во рёбер от корня до v(в ребре мб).
Как getLink(curr) влияет на depth(curr)
    1) подъём в начало ребра: depth -= 1
    2) переход по суфлинку от вершины node. depth += dt, where dt >= -1
        Поясним почему dt >= -1 при getLink(node).
        Заметим что по alpha/beta рассуждениям каждая вершина(кроме первой, мб) на пути root -> ... -> node
        Перейдёт в нек. вершину на пути root -> ... -> getLink(node)
        // Первая в случае root --(letter)--> node1, может перейти в root, так что её не считаем
        А значит глубина уменьшиться не более чем на 1.
    3) спуск по рёбрам вниз: for ...: depth += 1
        // Операций третьего типа O(n), т.к. у depth множество значений [1..n],
        // а значит depth прибавилось не более 3n раз (пусть изначально ~= 1, затем (-= 2, += 2) (n раз), += n)

Замечание:
Если учитывать |alphabet| в асимптотике, то
    n|alphabet| памяти (массив)
    или
    n log(alphabet) времени (мап) 

Вопросы: 
1) Почему суфлинки остались валидными?
