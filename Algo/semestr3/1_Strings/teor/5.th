Суфф. автомат
Работа происходит с конечными детерменированными автоматами(уже давно, вроде).
Определение принимаемого слова и L(A) - языка, задаваемого автоматом.

Нашей целью будет - по строке S построить минимальный ДКА А, такой что, L(A) - в точности все суффиксы S.
В том числе eps in L(A).
Замечание: минимальный = по числу вершин.

Опр. Пусть L - язык, x,y - слова.
R_L(x) = {z | xz in L} - правый контекст x относительно L.
Условно - правый контекст - это то, что гугл вам предлагает(сам суффикс), когда вы начинаете вписывать
x ~L y, если R_L(x) = R_L(y).
Классы эквивалентности будем обозначать, как [x]_L

Теорема (Майхилла-Нероуда)
Пусть L - язык, причём k = {forall x | [x]_L} - количество классов экв-ти конечно
Тогда 
    1) любой автомат А, принимающий L, содержит хотя бы k вершин
    2) есть автомат А, принимающий L, в котором ровно k вершин

Нам важен пункт 1), док-во очевидное:
    Пусть вершин меньше, тогда две строки из разных классов будут считаны в одно состояние,
            Но, противоречие, т.к. множество возможных суффиксов - одинаковое

-- Построим алгоритм, который докажет 2). --
R_L(not substring of S) = empty_set // такие строки не рассматриваем
Зафиксируем, что L - язык всех суффиксов

Утв. Пусть R_L(u) = R_L(v)
Тогда (u - суффикс v) or (v - суффикс u).
Док-во:
Существует w: uw in L, vw in L => uw, vw - суффиксы L => один из них - суффикс другого.

Утв. Пусть С - класс экв. относительно ~L.
Тогда C - это какая-то строка u и несколько её самых длинных суффиксов.
Замечание: в классе С лежат именно подстроки, а не суффиксы
Док-во:
Пусть u - самая длинная строка в С, тогда все остальные строки в С - её суффиксы.
Пусть v in C => докажем, что все более длинные суффиксы u лежат в С.
R_L(v) = R_L(u). Пусть w - более длинный суффикс u, чем v.
Тогда R_L(w) in R_L(v), т.к. v - суффикс w.
Ан-но R_L(u) in R_L(w), т.к. w - суффикс u.
Откуда R_L(v) = R_L(w) = R_L(u);

Опр.
Обозн. [x]_L, R_L <-> [x], R
// При фикс S.
longest(C) - самая длинная строка в C.
len(C) = |longest(C)|
link(C) - суффиксная ссылка класса С
link(C) = [x],  где x - самый длинный суффикс строки longest(C), который не лежит в С
Замечание: |C| = len(C) - len(link(C))

Утв. (Критерий longest).
Пусть u - подстрока s. 
Тогда u = longest([u]) <=> (u - префикс s) or (сущ. a != b, that au, bu - подстроки S)
Д-во.
1) Пусть u != longest([u]), тогда u ~ cu
R(u) = R(cu) => u and cu имеют одинак. множ-ва концов вхождений в S.
Тогда очев не верно ни (u - префикс s), ни (сущ. a != b, that au, bu - подстроки S)
2) Пусть u = longest([u]) and u - не префикс S.
Рассмотрим все вхождения u в S, а затем перейдём к символам перед вхождениями.
Пусть они все одинаковые и равны t, ну тогда R(tu) = R(u) -> u != longest(C), т.к. tu in C

Алгоритм построения суф. автомата
1) Инкрементальный подход.
2) Не следим за терминальностью (проставим в конце через прыжки по суфлинкам)

Пусть для строки S - построен суф. автомат
Затем приписываем символ c к S.
Хотим перестроить автомат.
Следить за классами экв-ти <=> следить за лонгестами.
Вопрос - как поменяется множество лонгестов?

Замечание: Если u была лонгестом, то u - останется лонгестом (см. Критерий)
Т.е. лишь могут появляться новые лонгесты.

Замечание:
В том числе: Sc - новый лонгест
Опишем класс [Sc]_Sc: множ-во всех суффиксов Sc, не являющихся подстроками S.
    Это правда, ведь R_Sc(Sc) = {eps}

Замечание:
Пусть T - какой-то ещё новый longest.
Тогда T - подстрока S, т.к. по пред. замечанию все неподстроки лежат в другом классе.
T - ранее не была лонгестом, а значит по критерию:
S:  |--xT--xT---|
Sc: |--xT--xT--yT|
Таким образом:
1) T - подстрока S
2) T - суффикс Sc
3) yT - не подстрока S

Вывод:
Единственный кандидат на роль T - максимальный суффикс Sc, являющийся подстрокой S.

Вывод:
Может прибавиться не более двух новых лонгестов (ака новых состояний).
Обозначим S0 - max суффикс Sc, явл-ся подстрокой S.
Заметим:
link([Sc]sc) = [S0]sc
Т.к. S0 это наибольший суффикс Sc, который не лежит в его классе(т.е. который явл. подстрокой S).
Опять таки он может просто не появиться, т.к. все суффиксы могут Sc
могут не являться подстрокой S.

ВНИМАНИЕ - переход к автоматам.
Утв. Пусть v - вершина автомата.
Рассмотрим все стрелки, которые в неё ведут(именно стрелки автомата). Тогда
1) На всех стрелках написана одна и та же буква
2) link(u_i) = u_i+1, forall i (именно линки)

Д-во:
    Замечание про автомат:
    Когда мы говорим строчки из класса v - имеем ввиду строки, которые автомат способен распознать,
    по итогу оказавшись в состоянии v.
    -- Как формируется С(v)? --
    Есть вершины, из которых ведёт ребро с letter в вершину v, а значит
    А значит в С(v) лежит объединение классов этих вершин,
    с добавленной буквой

Нарисуем все строчки, которые лежат в классе v:
|-----------| = longest(C)
 |----------|
  |---------|
   |--------|
Наблюдение 1: [eps] = {eps}, т.к. R(eps) = {все строки} и это будет корневая вершина.
Наблюдение 2: А значит у всех строк выше последний символ = c (т.к. все строки не пустые).
              А значит и символы на рёбрах автомата будут везде с, т.к. Замечание про автомат. (т.е. этот символ мы дописали в конце)
Наблюдение 3: Осталось заметить, что класс С разбивается на неск. последовательных групп,
              каждая из которых пришла из некоторой вершины u_i, приписыванием c,
              а значит, легко понять, что link(u_i) = u_i+1 
                // Ещё бы, ведь в u_i-1 лежат суффиксы u_i и более того последоавтельно

Инсайт:
Рассмотрим класс Sc // свежедобавленная вершина
Есть ребро S --(c)--> Sc
А затем путешествуем по link(S) и добавляем ребро link(S) ---(c)---> Sc

Продожение:
Утв. После добавления символа с - большинство рёбер в автомате не меняются
Потенц. изм:
    - Рёбра в [Sc]. Рёбер оттуда очев. нет(т.к. там есть длиннейшая строка).
    - Рёбра из-за расщепления (q -> q1, q2):
        - Рёбра в q расщепляются на два потока - в q1 и q2.
        - Рёбра из q расщепляются на два потока - из q1 и q2.

1) Какие рёбра стоит провести в Sc.
u1--c-->
..--c--> Sc
un--c-->
Ответ - создаём ребро с, если uc - суффикс Sc, но не подстрока S.
Алгоритм.
u1 = [S]
uk+1 = suflink(uk)
stop, when exists edge [un+1] --c--> ..(куда-либо).., (let name p = un+1)
Для вершин u1...un - причина провсести ребро:
    ну потому что uc - суффикс Sc, и uc - не подстрока S.
Для остальных вершин разберём кейсы.
Кейсы:
1) Дошли до корневой, и из неё также нет перехода по с.
Тогда Suflink(Sc) := root

2) Всё-таки существует вершина на пути un+1 = p, из которой есть
    переход по c.
Пусть переход по с из p ведёт в q.
    Тогда S0 это in q, S0 = longest(p) + c;
! В этом кейсе разбираем случай len(q) = len(p) + 1 // aka S0 = longest(q)
Т.е. q расщиплять нинада. 
В этом случае link(Sc) = q
// Ещё рассуждения про то, что из link(p), link(link(p) есть переход по с.
 
3) Аналогично 2), только S0 != longest(q)
Т.е. q расщиплять нада, и len(q) > len(p) + 1
Пусть q:
q: [-----------]
    [----------]
     [---------] = S0
      [--------]
       [-------]
Значит надо отрезать от q три последних суффикса и назначить из них
    новую вершину: clone

S0 = longest(clone)
    а) Рёбра из вершин с len > len(p) [которые link-1(p) и т.д.] остаются направляться в q(бтв. речь о u1, .. un).
    б) Рёбра из вершин p, link(p), link(link(p))...
        Нужно перенаправить в clone (ранее они были направлены в q).
    в) Рёбра из вершин q, clone
        R_sc(clone) = R_sc(q) |_| {Eps}
        Ну почему - у q ничего не изменилось, а для S0 - добавился только Eps, т.к. он явл суффикс Sc
        В итоге - все рёбра из бывшего q мы просто копируем в clone
        (clone отлич. только тем, что он терминальный, а q нет)
    г) Перепосчитаем все статистики 
    len(clone) = len(p) + 1 
    link(clone) = link(q)
    link(q) = clone
    link([Sc]) = clone

------------------------
Теперь про асимптотику.

Теорема(б/д).
В суффавтомате, построенном по строке длинны n:
1) <= (2n - 1) вершин
2) <= (3n - 4) рёбер
(При всех n >= n0)

Асимптотика:
O(n * log(Alphabet)) or (n * Alphabet)
1) Добавление рёбер в [Sc] - учтено в рёбрах
2) Самое сложное, только если расщепляется вершина q.
Единственное тонкое место лежит в пункте 3.б - перенаправление рёбер
Чтобы анализировать.
Рассмотрим путь по суфссылкам из S и Sc
Если раньше он был S ... un p link(p) .... root
То чем больше k - количество вершин ниже p, тем меньше длина пути Sc.
    Имеется ввиду, что путь по суффссылкам из Sc уменьшается на k
    И увеличивается на O(1) из-за новой Sc.
С лекции: pathSc <= pathS + 2 - k
Отсюда напряму следует, что сумма k есть O(n) 

Код:
    Строк 50

Задача: Есть шаблон p и текст t.
Найти все неточные вхождения с <= k ошибками
Для этого надо научиться быстро перемножать многочлены(лол?)
