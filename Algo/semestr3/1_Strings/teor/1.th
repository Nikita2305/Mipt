Задача, которую стоит решать - поиск подстроки в строке

1) Хэши
Создадим h(s): S -> Zm. имея ввиду что выбрано число m - модуль
Пример h(s) = (s[0] * p^(L-1) + s[1] * p^(L-2) + ... + s[L-1]) % m
Тогда распределение значений h(s) будет равномерным(прими как факт).
Откуда P(same_hash(s1, s2)) = (m - 1) / m

Алгоритм Рабина-Карпа.
Считай хэши всех префиксов текста text.
Считай хэш поисковой подстроки s.
Подстрока s входит с индекса i в текст, если hash(text[:i-1]) + hash(s) == hash(text[:i+L-1])
Асимптотика = О(n). Но с какой-то вероятностью он лажает - можно наивно проверять в таких случаях.


2) Префикс функция.
Пусть дана строка S. Тогда определим массив P той же длины, такой, что
P[i] - длина макс собственного суффикса строки S[:i], который совпадает с префиксом.
Пример:
s = ababbabbaaba
p = 001201201123 - префикс функция

Пусть есть алгоритм, находящий префикс функцию.
let S = pattern + "#" + text
find such i where P[i] == len(pattern)

Решётка # - важная деталь для доказательства алгоритма.

Сам алгоритм - будем вычислять P[i] последовательно
Вычсиляем P[i] через P[0] .. P[i-1]

Утв1. P[i] <= P[i-1] + 1.
Очевидно. Пусть нет и P[i] увеличилось на 2, тогда отбросив последний символ совпадающих супрефиксов,
получим противоречие с максимальностью P[i-1]

Замечание. Если посчитано P[i-1], то мы знаем, что начало и конец строки устроены одинаково.
Затем прыгнув в начало строки мы снова видим, что начало и конец локальной этой строки устроены одинаково.

Идея в том, чтобы перебрать все супрефиксы для i-1 в порядке убывания длины.
Ну и чё - вот взяли P[i-1]. Хотим некст. Ну прыгнули на префикс длиной P[i-1]. А там-то посчитана префикс-функция
Ну и мы такие j = P[i-1]. И далее такие нашли супрефикс P[j-1]. А теперь снова прыгнули на префикс длиной P[j-1].
И взяли k = P[j-1]. И нашли супрефикс длиной P[k-1]. И т.п.

Ну а дальше просто добавим проверочку s[i] == s[j]. То есть если новый добавленый символ совпадает
со следующим после супрефикса, то это наш ответ!

Асимптотика: O(n) времени и памяти.
Ключевой момент, в том что цикл работает O(n) суммарно.
Заметим, что j по факту плавно идёт по числам и в течение цикла увеличивается не более,
чем на 1 и не уменьшается ниже нуля

3) Z - функция
Пусть дана строка S. Тогда определим массив Z той же длины, такой, что
Z[i] - макс k, такое, что S[:k] == S[i:i + k]/
Назовём такую штуку(где эти подотрезки равны) - Z блок

Пусть есть алгоритм, находящий префикс функцию.
let S = pattern + "#" + text
find such i where Z[i] == len(pattern)

Решётка # - важная деталь для доказательства алгоритма.

Сам алгоритм - будем вычислять Z[i] последовательно.
Идея значит в чём. Давай хранить до куда мы максимально дошли Z-функцией
(имея ввиду блок, который смотрит дальше всех).
И значит вот мы стоим в i. Если оно в таком блоке лежит, то давай обратимся к i', которое лежит в префкс-блоке.
У него спросим Z[i'], а потом, если вдруг оно до края Z-блока, то давай попробуем увеличить ещё.
Ну вот, а если i не лежит, то давай просто будем с 0 пытаться увеличить Z-блок, пока это возможно.

Асимптотика очев O(n), т.к. границу Z блока мы двигали не более n раз а это и есть асимптотика.
