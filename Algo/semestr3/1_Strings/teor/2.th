Бор. Алгоритм Ахо-Корасик.

Опр. Бор - корневое дерево, на рёбрах которого лежат символы нашего алфавита.
Притом, из любой вершины не может исходить двух рёбер с одинаковыми символами.

Пример излишен.
Бор предназнаен для хранения набора слов.

Научимся строить бор по набору слов.
Слово хранится в боре, если существует путь из корня до "конечной" вершины, на рёбрах которого
хранятся символы слова в соотв. порядке.

Напишем код.
struct node {
    map <char, int> to;
    bool isWord;
};

vector<node> trie(1); // бор

void add(const string& s) {
    int v = 0;
    for (int i = 0; i < s.length(); ++i) {
        if (trie[v].find(s[i]) != trie[v].end()) {
            trie[v].to[s[i]] = trie.size();
            trie.push_back(node());
        }
        v = trie[v].to[s[i]];
    }
    trie[v].isWord = true;
}

Замечание. Вместо map можно использовать другие структуры.
Как например array, vector. Длина |Alphabet|. Unordered_map.
Однако это трэйдофф между памятью и временем.
С другой стороны, кажется, что unordered_map предлагает абсолютно лучшее решение,
в случае умения им пользоваться. (По словам лектора - хэш таблица при маленьких данных - плохой кейс)

Пример.
Задача - поддерживать мно-во чисел S:
            1) добавить x в S.
            2) узнать, есть ли y в S.
Решение - думать о числах как о битовых строках, а использовать бор.
Важный поинт в асимптотике, ведь теперь логарифм берётся не от количества элементов,
а от верхнего ограничения на S, и, более того, руками можно подгонять основание,
чтобы балансировать между памятью и временем.

Алгоритм Ахо-Корасик(женщина).
Задача. s1, ..., sn - словарь, эти слова назовём словарными.
Цель - найти общее число вхождений словарных слов в текст text.
Цель' - вывести все вхождения.

Решение - строим бор по словарю.
Пусть V - множество вершин бора, A - алфавит.
Проассоциируем вершину с префиксом, который она олицетворяет.
1) forall v in V
Определим link[v] - суффиксная ссылка, самый длинный собственный суффикс v, который есть в боре.
Небольшой референс к префикс функции.
Даже в самом плохом кейсе link[v] = 0, т.е. суффикс 0 длинны есть в дереве.
link[0] = -1, доп. кейс. К нему обращаться мы не будем, стоит это проследить.

2)  forall v in V,  forall c in A
Определим to[v][c] - самый длинный суффикс строки v + c, который есть в боре.
Важное отличие от link - это необязательная собственность.

Научимся находить link, to.

struct node {
    int to[|A|]; // Важно! Заметим, что мы можем смешать to!
    bool isWord;
    int link;
    node() {
        memset(to, -1, sizeof(to))
        isWord = false;
    `   link = -1;
    }
}

Будем искать с помощью ~bfs.
Будем хранить queue<int> q; - вершины, в которых расчитаны все статистики.

void Acho-Corasick() {
    t[0].link = -1;
    for (int c = 0; c < |A|; ++i) { // often |A| = 26  // что за цикл?
        if (trie[0].to[c] != -1) {
            continue;
        }
        trie[0].to[c] = 0
    }
    queue<int> q;
    q.push(0);
    while (!q.empty()) {
        int v = q.front();
        q.pop()
        for (int c = 0; c < |A|; ++c) {
            int u = trie[v].to[c];
            if (trie[u].link != -1) {
                continue;
            }
            
            // Надо понимать, что u может ссылаться ближе к корню, вследствие смешения.
            
            if (v != 0)
                trie[u].link = trie[trie[v].link].to[c]
            else
                trie[u].link = 0
            
            // |-----v-----|(c)
            //      |----u----| in trie
            // u.link = (v.link + c) 
            
            for (int d = 0; d < |A|; ++d) {
                if (trie[u].to[d] != -1) {
                    continue;
                }
                trie[u].to[d] = trie[trie[u].link].to[d]
            }
           
            // need coments
            q.push(u);
        }
    }
}

Асимптотика: O(|V| * |A|) - это идеальная асимптотика для подсчёта to, link, ибо объём полученных данных O(V * A)

Возвращаясь к задаче - разбёрём простой алгоритм, который будет пользоваться to[i][j]
let v = 0
for (int i = 0; i < n; i++) {
    v = to[v][text[0]] // i?
    Поинт в том, что v - это самый длинный суффикс слова t0...tj, который есть в боре.
    ans += sum_words(v) - количество терминальных вершин на пути до корня.
}
