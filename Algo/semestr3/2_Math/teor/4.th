Выпуклая оболочка.

"Векторное" произведение.
u = (x1,y1), v = (x2, y2)
[u, v] = x1y2 - x2y1 = |u| * |v| * sin(u, v)
Отсюда по знаку [u, v] можно определить "направление поворота".
Знак векторного произведения говори нам о направлении кратчайшего поворота u -> v,
+ -> против часовой
- -> по часовой
 
Опр. Пусть S - множ-во точек в R^2, |S| = n
Тогда выпуклой оболочкой S называется conv(S) = /\ {F, for F - выпуклое, F - содержит все точки S}

Замечание: conv(S) - min по включению выпуклое множество, содерж. S
Т.е. хотели сказать, что 

Док-во с помощью алгоритма:
Переберём все пары вершин.
Заметим что отрезок AB лежит, как ребро в выпуклой оболочке, если
все вершины лежат по одну сторону (либо на самом отрезке) от AB.
Тогда ч.т.д.

-- Более эффективные алгоритмы. --
Алгоритм1 (заворачивание подарка).
Асимтотика: O(n * h), где h - число вершин в conv(S)
Идея.
Выберем точки A, B - с минимальным Y. И minX, maxX, соотв.
Тогда либо A = B = Point, либо A != B
В любом случае A, B вершины conv, вместе с AB - ребро conv

Теперь находим самую правую точку Q*, относительно B.
Давайте поддерживать Q* - изначально любая != A, B.
Перебирая оставшиеся, как Q - будем проверять, что cross(BQ, BQ*) < 0.
    // поворот отрицательный
    // или cross(BQ, BQ*) == 0 and len(BQ) > len(BQ*)
Если так, то присвоим Q* = Q.
В конце получили Q* - верная.
Добавим в Q* в conv.
Переприсвоим A = B, B = Q*

Алгоритм2 (сортировка по координатам)
Асимптотика: O(nlogn).
S отсортируем по (x, y)

Построим нижнюю и верхнюю выпуклую оболочку.
Определение - это две последовательные части conv, разделённые крайними по X. Т.е. теми, что с Xmin, Xmax в рамках conv.
Идея: будем последовательно строить conv по sorted S.
Неформально: Пусть new лежит "снизу", тогда проведём две касательные к нижней выпукл. оболочке,
    вычеркнем все вершины, которые попали в кусок между касательными, добавим new.
Вопрос1. Как определять касательные.
Заметим, что критерий удаления - наклон стороны "меньше" чем наклон отрезка [new, V].
    Чтобы определять "меньше" - будем использовать cross(Q-P, P-new) < 0 // два отрезка [Q, P] и ...
Вопрос2. Че такое "снизу", а если сбоку?    
Заметим, что new всегда справа от многоугольника, а значит касательные всегда отсекают два крайних куска от
верхней и нижней выпукл. оболочки. Отсюда можно запустить по while-у в каждой оболочке и отбросить плохие вершины
из каждой.
Асимптотика sort + algos = O(nlogn) + O(n) = O(nlogn)

Алгоритм3 (сортировка по углу)
Асимптотика O(nlogn)
Идея:
1) Выберем точку с минимальным Y. Если таких точек несколько X. Назовём её O.
Теперь все точки лежат в верхней полуплоскости от O. Притом не лежат справа от O.
2) Отсортируем все точки по возрастанию угла.
Можно прям реально посортить по cos.
Можно сделать кастомный компаратор опять через cross
Если cross = 0, то компаратор по длине. (или скалярное произведение отрезка самого на себя = длина^2, чтобы не извлекать корень)
3) Будем в порядке такой сортировке добавлять вершины в conv.
Утв1. new вершину всегда стоит добавить в промеж. conv. (исходя из сортировки)
Утв2. перед этим надо удалить несколько вершин с конца стэка (да-да, храним conv в стэке, т.к. удалять с конца)
Хочется простого человеческого поворота налево, так что будем проверять, что новая точка под хорошим углом,
относительно двух последних. 


НОВАЯ ЗАДАЧА. Динамическая выпукл. оболочка.
Пусть есть два вида запросов:
1) Вывести выпукл оболочку
2) Добавить вершину
Будем поддерживать выпукл оболочку в формате верхней и нижней выпукл. оболочек(см Алгоритм2)
Идея:
Всё как и раньше, только храним теперь всё в set.
Что делать на запросе 2?
1. Точка внутри существующей оболочки
Ответ - ничего не делать.
2. Если точка слева или справа от многоугольника
Ответ - всё как в Алгоритме 2.
3. Если точка над верхней выпукл. оболочкой (б.о.о.)
Ответ - разрежем верхнюю выпукл. оболочку по new.x на два куска.
Далее через cross-ы проверим и отрежем несколько вершин справа от new.x и несколько слева.

НОВАЯ ЗАДАЧА. Max скалярное произведение.
S - фикс. множество на n элементов
Запрос - (a, b). Найти max {(a, b) * (x, y), for (x, y) in S}

Утв. Максимум достигается на одной из вершин выпукл оболочки.
Док-во. Для фикс (a, b) ГМТ точек с фикс скал. произв. - перпендикулярная вектору прямая.
Тогда двигая перп. прямую вдоль вектора (a, b), начиная с (0, 0), то
предельное значение для S очев. получим в некоторой точке выпукл оболочки (или на отрезке, но там аж две точки)

Как конкретно это делать?
Давайте разобём нашу оболочку на верхнюю и нижнюю опять.
Б.о.о. скажем, что b > 0, т.е. вектор условно говоря смотрит вверх., тогда рассмотрим верхнюю оболочку
Заметим, что если двигать последовательно по верхней оболочке, то скал. произв. растёт, а затем убывает.
Можно запустить какой-то бинпоиск или тернарный поиск для поиска максимума функции.

----
Если нужно решать одновременно две последние задачи одновременно.
Будем хранить ДД по неявному ключу (нужен доступ по индексу для бинпоиска, а в set так низя)
Асимптотика O(log^2n) на запрос. 

Упр. Можно за O(logn) на запрос.
