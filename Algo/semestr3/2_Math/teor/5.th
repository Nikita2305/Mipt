Лекция 11. (про сумму минковского)

Алгоритм 1.
Дано множество S. Хотим найти две самые удалённые точки.

Утв-е. Максимум достигается на выпуклой оболчке.
Пусть нет, но тогда продолжим отрезок в обе стороны до пересечения с выпукл. оболочкой.
Если попали в вершину conv, то найс.
Если на отрезок, то в одну из сторон вдоль стороны - dist увеличивается.
Откуда ч.т.д - возьмём ту вершину, в сторону которой оно увеличивается.
Проделаем дважды.

Тогда построим conv(S).

Пусть PQ - искомый диаметр.
Построим perp(PQ, P), perp(PQ, Q).
Утв. Они ограничивают полосу, в которой полностью лежит S.
Легко док-ть.

Тогда суть Алгоритма:
Пусть l1, l2 - те прямые, которые мы будем вращать(против часовой стрелки).
Изначально пусть выбрали некоторое направление. Пусть OX(1,0).
Найдём две крайние точки и проведём через них две вертикальные прямые l1,l2.
Теперь будем поворачивать их одновременно против час. стрелки.
Как только одна из прямых начинает содержать одну из сторон - переключаем прямую в другую точку этой стороны.
Проверяется через vect(u, v) <> 0.
Остаётся просчитывать для всех перебранных пар точек посчитать max{dist(p1, p2)}.
O(n).

Замечание. Если vect(u, v) = 0, то ничего страшного, можно переключать в любом порядке.
Ничего страшного = там две паралельных прямых, мы точно рассмотрим две диагонали.
А в трапеции - среди боковых сторон и диагоналей - максимум достигается в диагонали.
Почему? Ну потому что при боковой стороне есть тупой угол, а против него в одном из треугольников есть диагональ.
А значит для каждой стороны есть диагональ, бОльшая её.


Алгоритм 2. Сумма Минковского.
Пусть M1, M2 - два многоуг. (со внутренностями)
Опр. M1 + M2 = {a + b | a in M1, b in M2}

Утв. Сумма двух выпукл. многоугольников M1, M2 - тоже выпукл. многоугольник.
a) Выпуклость
let P, Q in (M1 + M2).
Тогда P = P1 + P2, Q = Q1 + Q2
Where P1,Q1 in M1;
      P2,Q2 in M2;
Тогда [Pi, Qi] in Mi. // отрезок полностью в фигуре.
Короче далее доказывается, что любая точка T на [P, Q] представляется как сумма двух точек
T1 на [P1, Q1] и T2 на [P2, Q2]. //Ну введи там аргумент t in [0..1]. И распиши координаты T.
// Или наоборот - координаты T1 и T2 с одинак. t и заметь, что получится T.
Откуда всилу выпуклости входных T1, T2 - лежат в многоугольниках,
 то и T лежит в (M1 + M2). А значит выпуклость - ч.т.д.

б) Почему же это многоугольник.
Утв. M1 + M2 = conv({P + Q | P in M1, Q in M2})
1)  conv(...) in M1 + M2. Последний - выпуклый. Под ... лежат точки из него. А значит ч.т.д.
2) Док-ем M1 + M2 in conv(...). Рассмотрим X1 + X2 in M1 + M2.
Тогда Xi лежит в треугольнике из триангуляции Mi.
X1 = a1 * V1 + a2 * V2 + a3 * V3.
X2 = b1 * U1 + b2 * U2 + b3 * U3.
//где a1 + a2 + a3 = 1, ai >= 0. Ан-но с bi.
Т.е. выразили Xi через вершины треугольника из Mi.
Тогда
X1 + X2 = (a1 * V1 + a2 * V2 + a3 * V3) + (b1 * U1 + b2 * U2 + b3 * U3)
Заметим также это = a1b1 * (V1 + U1) + ... + a3b3 * (V3 + U3).
Притом aibj >= 0, Sum_coef = (a1 + a2 + a3) * (b1 + b2 + b3) = 1.
А значит это выпукл. комбинация, т.е. X1 + X2 in conv({(V1 + U1), ..., (V3 + U3)}). Ч.т.д.

Утв, которым пользовались пару раз.(б/д)
X in conv({P1,..,Pn}) <=> [Существуют a1...an >= 0, a1+..+an = 1, такие что X = a1*P1 + ... + an*Pn]
Последнее выражение называется выпукл. комбинацией.

Алгоритм нахождения суммы Минковского M1 + M2.
Возмём две самые нижние, а затем левые точки M1, M2. Пусть это S1, S2.
Легко понять, что S1 + S2 лежит в M1 + M2.
Далее по возрастанию крутизны рисуем стороны M1, M2. Получится красный многоугольник c |M1| + |M2| сторонами (а значит и вершинами).
Замечание1. Поскольку сумма нарисованных векторов из M1 равна 0 и сумма из M2 тоже, то в итоге вернёмся в S1 + S2 // start

Осталось доказать, что это сумма Минковского.
1) Заметим наш многоугольник по крайней мере вложен в M1 + M2.
2) Пусть первые k сторон совпали. А потом какой-то вектор промазал.
По лекции - Промалаз = либо влево от нашего красного, либо вправо.
Условно говоря влево (внутрь многоугольника) не мог по (1).
Покажем, что и вправо не мог.
Ну пусть мог и ведёт в вершину (R1 + R2).
Тогда vect(P + Q --> R1 + R2) = vect(P --> R1) + vect(Q --> R2) = a + b
Заметим cross(u, a) >= 0, cross (u, b) >= 0
// поворот внутрь многоугльника, где u = тот вектор, который выбрали в многоугольник. (среди [P,P1] in E(M1), [Q,Q1] in E(M2))
// где E(Mi) - стороны многоугольников
А значит cross(u, a + b) >= 0, т.е. он тоже смотрит внутрь M1 + M2, ч.т.д.

Применения Суммы Минковского.

1) Проверить - пересекаются ли выпуклые многоугольники M1, M2.
Let (M1 - M2) = M1 + (-M2). 
Тогда пересекаемость <=> (0,0) in M1 - M2.
За O(NlogN);

2) Расстояние между выпукл. многоугольнками. 
Опять рассмотрим T = (M1 - M2).
Ответ = min {dist (X, (0,0)), for all X in T}
А чтобы это посчитать - достаточно посчитать расстояние от всех сторон/вершин.

Упражнение. Пусть рассмотриваем M1, M2 - невыпукл.
Триангулируем лошков, попарно треугольнички складываем и
объединяем все T1 + T2 в один большой многоугольник.
В качестве упражнения - как делать последнее.

Тут ещё чуть-чуть про определение принадлежности точки многоугольнику.
Можно трассировать луч, можно считать угол. Проблема с точностью имеет место.
Можно трангулировать - но долго - n^2.
Для выпуклого - есть алгос за O(logn) - разбиваем его на треугольнички с общей вершиной.
А потом бинпоиском ищем в каком кусочке бесконечного торта лежит точка и в конце проверяем, что она ещё и лежит в треугольнике.

