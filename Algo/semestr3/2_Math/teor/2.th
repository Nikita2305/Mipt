Упр. Алгоритм Карацубы
|----|----|
|----|----|
Умножать многочлены можно умножая их половинки, а потом как-то складывая.
Асимптотика умножения(рекурента)
T(n) = 3T(n/2) + O(n) = n^log(2,3)

Быстрое преобразование Фурье.
Умножение многочленов за nlogn
Пусть p(x) = a0 + a1*x + an-1 * x^n-1
Тогда p однозначно восстанавливается по своим значениям в произв. n попарно разл. точках.
(Если точек на одну больше, чем степень, то многочлен восстан.)

Цель - перемножить P и Q, получить R.
Алгоритм:
1) Найдём P, Q в точках x1...xn.
2) Поточечно перемножим и найдём таким образом значения R в этих точках
3) Восстановим R в этих точках.
Чтобы всё это работало: n > deg P + degQ. Положим n = deg P + deg Q + 1;

В качестве x-ов возьмём комплексные корни из 1.
Т.е. такие x на плоскости, что их модуль = 1.
Положим
x1 = 1
x2 = w
...
xn = w^n-1
where w = e^(i * 2pi / n)
// xi - повороты

1) Вычисление P(w^0), ..., P(w^n-1)
Для простоты будем считать P = a0 + a1x + ... + an-1 * x^n-1
Пусть
P0 = чётные члены
P1 = нечётные члены
P(x) = P0(x^2) + x * P1(x^2).
Считаем, что n - чётно. Достаточно посчитать значения P0 и P1 в точках (w0, w2, ... wn-2)
T(n) = 2T(n / 2) + O(n)
T(n) = O(nlogn)
// Изначально сделаем n ближ. степ. двойки.

2) Тривиально считаем R(w^j) = P(w^j) * Q(w^j)

3) Заметим что мы делали
(P(w^0))     (   w^(0*k)   )  ( a0 ) // for k = 0..n-1
(P(w^1))   = (   w^(1*k)   )  ( a1 )
(.....)    = (   .......   )  ( .. )
(P(w^n-1))   (  w^(n-1*k)  )  (an-1)

Квадратная матрица - матрица Вандермонда. Обозначим W.
Найдя обратную к ней, сможем найти коэфф-ты R через точки(как в рав-ве выше).

Найдём.
Рассмотрим Wij = w^ij. Vij = w^-ij
Док-ем. V * W = n * En
На диагонали действительно n = Summ(w^(ij) * w^(-ji)) = n * 1
Не на диагонали: Sum(j = 0..n-1, w^(-ij) * w(jk)) = Summ(j = 0..n-1, w^j(k-i)) = 0, как сумма геом. прогрессии
(1 + q + .. + q^n = (1 - q^n) / (1 - q), where q = w^(k-i). q^n = w^n^(k-i) = 1)

Таким образом запускаем первый шаг с w = w^-1 и в столбце R(w^i).
А значит находим коэфф-ты R.
А, да, и не забудь поделить его на n, ведь обратная матрица на самом деле в n раз меньше.

Задача решена за O(nlogn), где n = O(max(degP, degQ))

Погрешности: 
Копится существенная ошибка, но на практике 
Если перемножаем целочисленные многочлены, то погрешность невелика, если коэф-ты R <= 10^11 or 10^12.
Рез-т понятно, что целочисленные многочлены, так что тут мы ещё и округляем коэф-ты R на последнем этапе.

Разворачивание рекурсии.
Заметим единственная содержательная функция - найти решение системы уравнений(которая в пункте 3 нарисована)
Посмотрим, как работает FFT на массиве длины 8.
s(a0,a1,a2,a3,a4,a5,a6,a7,a8) // s = solve
from
s(a0, a2, a4, a6) and solve(a1, a3, a5, a7)
from
s(a0, a4), s(a2, a6) and s(a1, a5), s(a3, a7)
from
s(a0),s(a4),s(a2),s(a6),s(a1),s(a5),s(a3),s(a7) // Тут очевидны значения выражений на w^0 (=ai) 

Значения выражений на w^0, w^4 у многочлена a0 + a4 * x  //  s(a0, a4)
w^0 = 1, w^4 = -1 => a0 + a4, a0 - a4

Цель - развернуть рекурсию сверху вниз. Наклёвывется нумерация из ДО и просто пушбэк def(f[i], f[i + 1]), i+=2;
Поймём, как получился порядок a0, a4, a2, a6, .... (который внизу)
Заметим получился список a_rev(0), a_rev(1), a_rev(2),....
Где rev(x) - число полученное через ревёрс битового представления числа x. (в контексте того, что n = 2^k
                                                                            и ревёрс первых k бит числа,
                                                                            остальные - нули)
Очев. этот порядок можно посчитать за nlogn, явно посчитав rev(i) forall i, и это нас удовл.

Однако можем за O(n), почему бы и не сделать:)
rev[0] = 0;
oldest = -1
for (int mask = 1; mask < (1 << k); ++mask) {
    if (mask & (mask - 1) == 0) ++oldest;
    rev[mask] = rev[mask ^ (1 << oldest)] | (1 << (k - oldest - 1))
}

Утв. Можно обойтись без привлеч. доп. памяти на этом этапе(nizhe).

Заведём массив b, в который запихнём a_rev(0), a_rev(1), ...
Пусть мы на уровне j. (Изначально j = 0)
А значит, чтобы получить массив b уровня повыше, то нам нужно скомпановать числа нашего массива по 2^j чисел.
А затем эти блоки по два "обработать" и создать блоки 2^(j+1)
(В случае j = 0: было a0,a4 => стало a0 + a4, a0 - a4)

"Обработка":
T(x) = T0(x^2) + x * T1(x^2)
Пусть w - корень из 1 степени 2^(j+1) = J, Тождества: w^J = 1, w^(J/2) = -1
Ищем T(w^0), T(w^1), ...
T(w^s) = T0(w^2s) + w^s * T1(w^2s)
T(w^(1/2J + s) = T0(2s) - w^s * T1(w^2s) // Юзаем тождества две строчки выше


Код.
for (int j = 0; j < k; j++) { // n = 2^k
    // w = sqrt(2^j+1, 1)
    // Ещё и сохраним все степени омеги
    for (int i = 0; i < n; i+= 2^j+1) {
        for (int s = 0; s < 2^j; ++s) {
            x = arr[i + s]
            y = arr[i + s + 2^j] * w^s;
            arr[i + s] = x + y;
            arr[i + s + 2^j] = x - y;
        }
    }
}

Заметим, мы всё.

Новый топик. Отказ от комплексных чисел и переход в Zp.
Т.е. допустим надо найти коэф. в поле Zp.
Если p = 2^k * r + 1;
// r - неч.
То существует такой элемент w in Zp, что w^0, ... w^(2^k-1) - различные. И w^(2^k) = 1

Классический пример p = 998244353 = 119 * 2^23 + 1
Тогда возьмём w = 31.

Если p - другое, то наивно перебором найдём w.

Зачем ещё бывает нужен переход в Zp.
Пусть степени P, Q ~= 10^5, и a_i ~= 10^5, а значит коэф-ты ~=10^15

Сделаем следующее. Посчитаем их произведение по модулю p1, p2.
ans_i = x (mod p1)
ans_i = y (mod p2).
А значит ans_i однозначно, если ans_i < p1*p2, по КТО.
Достаточно подобрать достаточно большие p1, p2.
