Теория чисел.

Алгоритм Евклида - способ вычислять 
НОД: (а, б) |--> НОД(а, б) =: (а, б)

Утв. (a, b) = (a, b - a), where (b >= a)
1) Пусть (а, б) = d.
(a, b - a) делится на d, сл-но (a, b - a) >= (a, b)
2) Пусть (а, б - а) = q
(a, b) делится на q. сл-но (a, b) >= (a, b - a)

В общем случае можно брать (а, б) = (а, б % а)

Расширенный алгоритм Евклида
Пусть (а, б) = d.
Тогда ищем x,y: ax + by = d, // Линейное представление НОД
Пусть найдены: x1, y1, т.ч.
(b % a)*x1 + a*y2 = d
(b - a * [b / a]) * x1 + a * y2 = d
a(y1 - [b / a]* x1) + b * x1 = d // Значит можем найти и x,y

x = y1 - [b / a]* x1
y = x1

---------------------

Теорема 1(б/д).
Пусть Pi(n) - кол-во простых чисел среди первых n натуральных.
Тогда Pi(n) = n / ln n + _O_(n / ln(n) ^ 2)

Теорема 2(б/д).
f(n) = Sum[p<=n](1/p) = ln(ln(n)) + M + O(1/ln(n)),
M ~= 0.261

Теорема 3(б/д).
q(n) = Sum[k <= n](1/k) = ln(n) + fi + O(1/n)
fi != 0.577.

Решето Эратосфена.
Задача: Найти все простые среди 1...n

Предложение1: Запустить n алгоритмов, каждый за O(sqrt(x)) - долго.

Предложение2(алгоритм):
Сперва будем счиать, что все числа простые(кроме 1).
Затем последоавтельно(начиная с 2) будем обрабатывать числа:
    1) Если p - простое => k * p - составное, для k > 1.
    2) Если p - составное, то ничего не делаем.
Корректность очевидна.

Асимптотика:
Sum[p <= n, p - prime](n / p) = O(n * ln(ln(n)))

Замечание:
Следующим продвижением будет написать решето Эратосфена за О(n)
Более того, наше новое решето будет искать минимальный простой делитель для каждого x in [1..n]
// Обозначим эту статистику - min_d

Предложение3(новый алгоритм):
vector<int> primes;
min_d[2..n] = {2, ..., n}

for k = 2 ... n {
    if (min_d == k) primes.pb(k);
    for (p : primes && p * k <= n && p <= min_d[k]) {
        min_d[p * k] = p
    }
}

Корректность.
1) min_d[p] определится верно => праймс также корректен.
2) Пусть x - не простой и q - его минимальный простой делитель.
    Когда k = x / q ; p = q, выполним min_d[x] = q;

Асимптотика.
min_d[x] когда-то найдётся, более того мы изменим его значение ровно 1 раз, а значит асимптотика O(n).

Замечание: Факторизация всех этих чисел очевидна и после решета работает слишком быстро! 

Факторизация произвольного: sqrt(x).


Обращение по модулю.
Пусть (a, m) = 1. Тогда существует x, ax = 1 (mod m). Этот x - назовём обратным к a.

Утв. В произвольном случае x можно найти с помощщью расшир. Алгоритма Евклида.
Замечание: в простом через МТФ.


ОФФТОП:
Криптографические протоколы
Открытый канал: Алиса - Боб. Однако сообщения зашифрованы.
Подслушиватель: Ева.

1) Гаммирование
База: А и B тайно договариваются о секретном ключе.
Пусть x - битовая строка длины n. Случайная
Сообщение: y
Пересылка: (x xor y)
Получение: (x xor y) xor x = y

Проблемы:
1. Необходимость встречи.
2. Возможность получить (y xor z) - частичная информация.

2) Алгоритм Диффи - Хеллмана [способ решить проблему 1]
Алиса и Боб договариваются о p - prime, g - первообразный корень по модулю p.
Т.е. степени g - есть все ненулевые остатки по модулю p.

А публикует p, g в открытом доступе.
А гененрирует а, B генерируют b - числа в секрете.
Алиса отправляет g^a, Боб отправляет g^b.
Алиса знает a, g^b; Боб - наоборот.
Они оба могут получить g^(ab).
Это g^(ab) можно использовать как секретный ключ.

Секретный ли он?
Ева знает: g, p, x = g^a, y = g^b

Самое простое что хочет сделать Ева: 
Найти то самое а, что g^a = x.
Притом не существует полиномиального алгоритма его нахождения, а значит ура.
Существует алгос за O(sqrt(p)).

3) Протокол RSA.
Позволяет обеспечить одностороннее общение.
Боб генерирует различные простые p, q.
И публикует N = p * q. А также e, т.ч. (e, (p-1)(q-1)) = 1.

Сообщение Алисы: x
Отправлено: x ^ e (mod N)
Принято Бобом: x ^ e (mod N)
Он находит d - обратное к e, по модулю (p-1)(q-1).
И вычисляет (x^e)^d, mod N // = x, почему? А вот почему

--
Теорема Эйлера.
Если (a, n) = 1, то a ^ phi(n) = 1 (mod m)
where phi(n) - функция Эйлера
phi(pq) = (p - 1) * (q - 1)
--

e * d = 1 (mod (p-1)(q-1))
А значит x ^ (ed) = x ^ (k * mod + 1) = x, mod N

Что делать Еве?
1) Сделать разложение N = p * q
2) Искать решение задачи дискретного логарифмирования
Обе эти задачи не слишком простые.

На этом ликбез окончен.



Алгоритм Штрассена.(затравочка к ФФТ)
Пусть есть две матрицы А и B. Размера 2^k * 2^k
Наша цель - найти С = А * B.

Наивный алгоритм: O(n^3), where n = 2^k

Алгоритм(Штрассена):
Положим
А = (A11 A12)
    (A21 A22)
Ан-но B, C;

P1 = (A11 + A22)(B11 + B22)
P2 = (A21 + A22)B11
P3 = A11(B12 - B22)
P4 = A22(B21 - B11)
P5 = (A11 + A12)B22
P6 = (A21 - A11)(B11 + B12)
P7 = (A12 - A22)(B21 + B22)

Утверждается что С как-то через P составить.
Рекурента T(n) = 7 * T(n / 2)
T(n) = O(n^log2(7)), log2(7) ~= 2.8
Притом алгорим ещё и хорошо параллелится

C11 = P1 + P4 - P5 + P7
C12 = P3 + P5
C21 = P2 + P4
C22 = P1 - P2 + P3 - P6

Пруф:
C22 = A21 * B12 + A22 * B22
Далее раскрываем скобки(идём от P-шек) и верим в лучшее.

Числа Стирлинга (1 и 2 рода).

1 род.
x(x - 1)(x - 2) ... (x - n + 1), где x - не обяз целое число.
Наш вопрос состоит в том, чтобы понять коэффициенты s(n, k) = числа стирлинга
= Sum[k = 0...n](s(n, k) * x^k)

Зачем?
Sum[k = 0..n](k^2 * C(n, k))
Можно разбить kk = k(k - 1) + k
Похожие задачи возникают при распределении Пуассона.
Короче есть тут какая-то связь с первым родом.

Утв. |s(n, k)| = число перестановок на n эл-ах, которые имеют ровно k циклов.
Доказать это можно, доказав рекуренту.
s(n+1, k) = n * s(n,k) + s(n, k-1), k>=1
s(0, 0) = 1, s(n, 0) = 0, n >= 1.

Можно найти за квадрат n короче числа С. 1 рода

Числа Стирлинга второго рода.
Тоже за квадрат считаются, решают противоположную задачу.












