Лекция про геометрию.
Элементарная геометрия и триангуляция.

Точки, векторы в R2.
Каждая точка задаётся (x, y)
struct point {
    double x;
    double y;
}

point operator-(const point& other) {
    return {x - other.x, y - other.y};
}

point operator*(int k) {
    return {x*k, y*k}; 
}

// Оо, чтобы избавиться от вертикальных прямых
// - можно повернуть картинку на рандомный угол
Но мы будем делать так:

struct line {
    int a, b, c;
    line(point p, point q) {
        a = q.y - q.y;
        b = p.x - q.x;
        c = p.x * q.y - q.x * p.y;
    }
};

Чё как нормальный вектор к прямой сделать?
Ну берёшь такой точку на L. Берёшь направл. вектор v = (p1 - p2)
Нормальный вектор: q = {-v.y, v.x}
Ну и теперь по точке и q строим перп. прямую.

Расстояние от точки до прямой.
double dist(point, line) {
    return fabs(f(point)) / sqrt(line.a^2 + line.b^2);
}
// Небольшой пруф с поиском точки q, как q = point + norm * t;
// И затем поиск t, чтобы q лежала прямой

Пересечение прямых.
Метод Крамера.
{ a1x + b1y = -c1
{ a2x + b2y = -c2
Найдём det матрицы 2х2. Если 0, то соболезнуем (либо парал, либо совп).
Иначе посчитаем
det1 = -c1b2 + c2b1 // подставим вместо первого столбца - столбец ответов
det2 = -a1c2 + a2c1 // подставим вместо второго столбца - столбец ответов
Тогда 
(x) = (det1 / det)
(y)   (det2 / det)

Замечание: прямые совпадают, если коэф-ты пропорциональны.
Другая идея - взять какую-то точку на прямой и проверить,
    что она лежит на другой.
Общее замечание к двум. посл. строкам - стоит отлавливать случай:
    coef == 0


Пересечение окружности и прямой.
Пересечение есть <=> dist(center, line) <= r
Наивно можно решать систему пересечения двух геом. объектов.
Но чёт дрочно, давайте более экономно с точки зрения кода.
Опустим перпендикуляр из сenter на line.
Положим l = sqrt(R*R - d*d)
Если l = 0 => точка касания
Иначе от проекции center на line отступить напр. вектор длины l в обе стороны.

Пересечение двух окружностей.
Заметим, что если вычесть уравнения окружностей, то получится уравнение прямой, проходящей через точки пересечения окружностей.
Далее пересечём окружность и эту прямую.

Скалярное и псевдовекторное произведение.
Скалярное.
(u,v) = x1x2 + y1y2
(u,v) = |u|*|v|*cos(phi) // (б/д)
cos(phi) > 0 при остром угле.
cos(phi) = 0 при прямом
cos(phi) < 0 при тупом

Псевдовекторное - потерялось. 

Про точность - чем меньше вызовов acos и т.п., тем лучше точность

Триангуляции многоугольников.
Опр. Диагональ - отрезок между несос. верш, целиком леж.
    во внутренности многоугольника
Задача - найти кол-во точек, из которых видна любая точка полигона.
Упр. Треугольников в триангуляции ровно (n-2).
Упр. Из этой конструкции можно показать, что дост. n/3 точки.
Упр. Бывают многоугольники, достиг. этой оценки.
    // n/3 - const

Триангуляция за O(n^2).
Выпуклый -> O(n)
Иначе -> ?

Опр. Ухом в многоугольнике называется треугольник (vi-1, vi, vi+1)
который целиком лежит в многоугольнике, и при этом внутри этого
треугольника нет других вершин.

Пример - нарисуй варежку и отрежь ей два пальца одной прямой.
Пусть оставшееся - треугольник, тогда:
Получишь пример, когда в треугольнике есть четвёртая вершина(на грани)

Утв. В любом простом (без самопересеч.) многоугольнике с n >= 4
есть хотя бы два непересек. по внутр. уха.

Д-во. Индукция по n.
База. n = 4 => всего два дефолт 4-угольника. В обоих есть два уха.
Переход. Рассмотрим произв. выпукл вершину vi. // угол < Pi
Если vi - обр. ухо - отлично. Переход индукции работает очевидно
Иначе найдём вершину q - самую близкую к vi.
Утв-ся, что (q, vi) - диагональ.
Разделим многоугольник на два, и по переходу снова найдём два уха.

Алгоритм трианг-ции.
Поддерживаем верш-ны многоугольника в двусвяз. списке.
FindEar -> T(n) = O(n) + T(n/2)
Найдём vi - выпуклая. // O(n)
Если ухо - отрежем.
Иначе - разрежем многоугольник на 2(по утв. выше),
запустимся рекурсивно от меньшего. // T(n/2)

Существует алгоритм за O(nlogn)
