Продолжение про принадлежность точки многоугольнику.
Трассировка луча.
1) Подсчёт количества пересечений с многоугольником.
Проблема: вершины многоугольника могут попасть на луч.
При невыпуклом многоугольнике есть два случая, которые мы не можем различить:
1. Вершина вне. Луч проходит через "ухо", т.е. через такую высунувшуюся вершину.
2. Вершина внутри. Луч проходит через вершину.
И там и там пересечение 1, но ответы разные.

Решение проблемы №1. Пускать случайный луч вместо горизонтального.
Некруто: потому что может получиться double (получится).

Решение №2. Пусть все точки имеют целочисли. координаты в [0, A] x [0, A]
(если что подвинем)
Тогда пустим луч p(A, A + 1).
Несложно доказывается, что этот луч не проходит ни через какую точку [0, A] x [0, A].
(чуть-чутьб математики)
Некруто: нужно знать А (т.е. решение зависит от многоугольника).

Решение №3. Пускать горизонтальный луч(направо) и разобраться с вершинами на этом луче.
Пусть p - исходная точка.
Пусть AB - сторона многоугольника. При необходимости свапнем A и B так, чтобы B.y >= A.y
Рассмотрим кейсы. 
1) Если B.y <= P.y или A.y > P.y. => continue
Второй случай - очев, т.е. AB выше луча
Первый случай - объединение трёх возможностей.
    1.1) Полностью ниже луча
    1.2) Касается луча снизу
    1.3) Лежит на луче
Теперь можно считать, что А либо снизу либо на луче. B строго выше.
2) Если cross(p - a, b - a) < 0 => cnt++;
Речь о том, чтобы проверит, что отрезок именно пересекает луч, а не просто прямую.
Разбор случаев. (хотя мне кажется, что просто провека, что p лежит с нужной стороны от AB)
3) Конечная проверка: 
if (cnt % 2 == 1) => inside
else => outside

Замечание - стоит отдельно проверить, не лежит ли точка на границе многоугольника.
Асимптотика. O(n)
Проверим Корректность. Остался вопрос с неучтением 1.2)
Вот тут как раз можно перебрать случаи (4 штуки), как располагается угол ABC относительно луча
// C - следующая вершина
Вниз, вниз (Вверх, вверх): // += 1
/
\
Вниз, вверх (Вверх, вниз): // += 0 or 2
\/
Эти случаи удачно обрабатываются, относительно чётности.

Ещё один кейс - AB лежит на луче. Он алгоритмом отсечётся на 1.3)
Его можно не учитывать в понимании (что наш алгос и делает), т.к. он по факту просто переносит рассмотрение
из А в B. 


Пересечение полуплоскостей.
Есть n полуплоскостей. Каждая - прямая + вектор направленный внутрь.
Как выглядит?
Либо бесконечная полу/четверть-плоскость (либо пустое). Либо выпуклый многоугольник.
Выпуклость, т.к. пересечение выпуклых фигур.
Как храним полуплоскости?
Давайте ax + by + c >= 0.
Заметим (a, b) указывает внутрь полуплоскости.
Т.к. a(x0 + a) + b(y0 + b) + c = aa + bb > 0
Будем считать векторы нормалей нормированы.

Считаем, что в множестве полуплоскостей есть такие полуплоскости:
x <= inf, x >= -inf, y <= inf, y >= -inf.
Тогда пересечение бесконечно <=> в нём есть одна из этих крайних точек.
inf надо подбирать, так чтобы любое пересечение было внутри.
Теперь можно считать, что пересечение всегда конечно.

Алгоритм за O(n^2).
Откусываем от (bounding box)-a по очереди кусочки.
Получаем O(n) вершин в bounding-box и n раз пересеч полуплоскость с ним стоит O(n^2)
Коротко о пересечении полуплоскости и многоугольника:
1) Если все вершины с одной из сторон от прямой. => очевидно
2) Иначе случай невырожден.
Тогда для каждой стороны проделаем это:
2.1) Если (vi, vi+1) не лежит целиком в полуплоскости - ничего не делаем
2.2) Если (vi, vi+1) лежит целиком в полуплоскости - добавляем vi+1
2.3) Если vi не лежит, vi+1 лежит => add intersection, add vi+1
2.4) Если vi+1 не лежит, vi лежит => add intersection

Алгоритм за O(nlogn)
Разобьём полуплоскости на 2 класса: куда смотрит вектор нормали.
1) [0, pi) <=> b > 0 or (b == 0 and a > 0)
2) [pi, 2pi)

Как выглядит полуплоскости из (1).
Если их всех пересечь, то получится нижняя выпуклая оболочка.
(2) - аналогично - верхняя выпуклая оболочка.

Внутри каждого класса отсортируем все полуплоскости по углу нормали, используя векторное произведение.
Мы так уже делали ранее, написав прикольный компаратор. O(n logn)

Объеденим отсортированные списки полуплоскостей (1) и (2).
(По факту просто отсортировали список по возратанию угла наклона 0..2Pi)
Можно было через acos/asin переходить явно к углам и сортировать без разделения, но это не круто.

By the way, Deque = double ended queue
Будем в деке хранить наш bounding box (как в алгоритме n^2), притом границы будут лежать по очереди.
Заметим, что очередная полуплоскость может выкинуть только отрезки с конца и с начала.
Проверка нужности стороны через проверку принадлежности старой вершины новой полуплоскости.
Затем мы добавляем в конец нашу новую полуплоскость в дек.

После этого for сделаем ещё два while.
Пока (в деке хотя бы 3 полуплоскости и точка пересечения последних двух не лежит в первой)
    deque.pop_back
Аналогичный while с началом. 

if (в деке <= 2 полуплоскостей) => ans = none
else в деке лежат стороны искомого

Поясним глубинное значение этих while.
В нашем for мы всегда добавляем новую полуплоскость.
А это значит что после исполнения for в конце могут лежать бесполезные полуплоскости
Вот как их проверять, что последняя полуплоскость бесполезная => inters(last, prelast) not in first_halfspace

Замечание: что делать с прямыми у которых нормали параллельны.
Среди параллельных полуплоскостей(сонапр, но не параллеьные нормали) нужно оставить с = min{c, ax+by+c}
Заметим, что у нас могут остаться параллельные прямые, с разными направл. нормалей.
Это тоже стоит обойти так: если нас просят пересечь параллельные полуплоскости, то это значит,
что они оказались соседними в деке, а значит мы удалили все полуплоскости между ними,
в т.ч. одну из прямых баундинг бокса. А этого быть не могло, если всё корректно.
А значит если нас просят пересечь пар. прямые, то стоит выдать ответ, что пересечение пусто (или беск, хз)

Замечание:
Если нашей целью является получить корректный многоугольник(типа без повт. вершин),
то нужно ещё убрать дупликаты точек пересечения(они будут идти подряд).
Это чтобы перестраховаться от полуплоскостей которые касаются нашего многоугольника по вершине и вошли в ответ.

Замечание: зачем нормировали норм. векторы?
Ну например тогда сонапраленность <=> равнество нормалей.
Тогда в предпредыдущем замечании пар. плоскости проще отсекатью
