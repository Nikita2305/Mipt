# Про списывание на финальной КР - Бан баллов за сем + пишут служебку в учебное управление

Антипаттерны - типовые косяки(1 лекция)
Разделим на группы
1) В ООП
2) В Кодировании
3) Методологические
4) Управление конфигурацией
5) Прочее

1. ООП.
- Базовый класс утилита
    // т.е. наследование класса DocWriter от FileReader, чтобы получить возможность читать доки
- Anemic Domain Problem
    - боязнь размещать логику в объектах предметной области
    // Т.е. правильно и стоит добавлять члены класса, которые не соответствуют в точности реальному миру
    // но удобны для реализации, напр. Auditory.close(). Хотя на самом деле их кто-то закрывает
- Вызов предка
    - Для реализации функциональности методу протомка приходится вызывать тот же самый метод родителя
    // Т.е. напр. сначала вызовется метод родителя, а потом его return как нибудь декорируется
    // Почему плохо - изменение метода предка ломает методы детей.
    // Решение - разделить наследуемые и не наследуемые объекты точно
- Ошибка пустого подкласса 
    // B: public A. A a(); B b(); , f(a), f(b)
    // f(A& value): if (typeof(value) == A) do(); else doelse();
    // Ожидается одинаковое поведение
- Божественный объект
    // БОльшая часть функциональности данного уровня абстрактности делегирована одному классу
    // Класс Game - распределяет ответсвенность между другими - так вроде можно
- Объектная клоака
    // Переиспользование объектов, находящихся в непригодном для использования состоянии
    // Пример - необходимо удалять настройки прошлого пользователя, когда он вышел из системы принтера
        // перед тем как новый юзер будет использовать Printer.print()
- Полтергейст
    // Объекты, чьё едиснтвенное предназначение - передавать данные другим объектам
    // Но всё-таки бывают случаи, когда это норм - паттерн Медиатор(хотя не совсем туда).
    // Пример Медиатора - самолёты контачат через самолётную вышку
    // Он выполняет некоторую логику по распределению
- Проблем йо-йо
    // Чрезмерная размытость сильно связанного кода по иерархии классов
    // A -> B -> C - классы. Постоянные dynamic_cast и вызовы методов
- Одиночество
    // Неумелое использование Singleton
    // Правильное понимание - когда объект по логике должен быть один и создание второго приведёт к проблемам
    // например - доступ к файлам одновременным
    // Важно, чтобы второй было создать низя
