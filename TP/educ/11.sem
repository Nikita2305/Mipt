Паттерны.

Memento pattern(Snapshot)
Короче идея - нужно сделать граф диалогов.
И иногда делать snapshot - снимок нынешней системы графа. ?
Утв: хочется сделать другой класс(GraphSnapshot)
Вопрос: можно ли делать публичными / приватными поля snapshot'a? Ответ: нет - нет
Утв: дружим классы Graph и Snapshot(тут всё делаем приватным), чтобы только Graph мог обращаться к snapshot.
    Замечание: например - у класса Graph есть: // Snapshot getSnap(); // void Load(Snapshot&) //
Замечание(смежное): это про то, чтобы на каждом ходе сохранить информацию о состоянии игры


Новый паттерн. Двойная диспетчеризация (Visitor pattern).

Рефлексия - способ (в рантайме/компайлтайме) посмотреть на сущности кода(ака структуры, классы и т.п.) и смотреть на их поля и т.п.
    Однако когда такая возможность есть, код можно декомпилировать.

Так вот, хотим сюрреалезовать граф.
    Предложение: у класса Node добавим класс serrialize() - но зачем Node знает, куда (в JSON) её сюрреализуют?

Тезис - хочется добавлять виды поведений, а не виды объектов, как обычно(Unit ---(inheritance)--> U1, U2, U3, ...)
    Предложение: для каждого поведения создаём класс F1, F2, ...
    // Рабочие типы: T1, T2, .. (наследованы от IT, у которого определён метод virtual visit(IVisitor) - см. далее)

Предложение2: Наследуем F_i: IVisitor {} (у которого определён virtual acceptT1, acceptT2, ...)
Задача: хотим к t1(T2) применить поведение f2(F2)
    t1.visit(f2)
where:
"visit" in T1 calls:
    v->acceptT1(this)

Утверждение: с помощью двух полиморфизмов решили задачу.



