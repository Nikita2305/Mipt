Fly Weight pattern - легковес.
Пример. Если много юнитов с одной картинкой, то стоит создать класс Image.
И в юните хранить не поле = картинка, а ссылку на картинку.
Более того класс Image должен быть имутабельным. Т.е. если один юнит меняет свою Image, то она должна копироваться
и присваиваться ссылка на новую картинку.

Proxy pattern.
DbConn - подключ. к базе данных.
    std::string get(int);

1) Db connection - быстро создаётся, много весит.
    Не хочется его хранить, но хочется создавать каждый раз?
    Решение: LazyDbProxy: IDb;
        get() - создаёт объект DbConnection: IDb и вызывает там get() и удаляет например.

2) Хотим логировать вызовы DbConnection.
    Решение: LogDbProxy.

3) Хотим хэшировать.
    Решение CacheDbProxy.

Суть одна и та же.

Очень похоже на декоратор - в чём разница?
    Proxy - это класс который притворяется другим классом, на самом деле не являясь им
    Декоратор же открыто заявляет, что он декоратор.
    Т.е. когда юзаем декоратор - понимаем что его. Когда прокси - не понимаем что его.

gMock - тестирование GTEST. Большие возможности.
google.github.io/googletest/gmock_for_dummies.html

Какая-то ещё штука для Java.
habr.com/ru/post/444982/

TDD - Test Driven Development
1) Пишем тест, который не проходит (RED)
2) Пишем миним. код, который проходит тест(GREEN)
3) Адаптируем код так, чтобы он выглядел красиво(REFACTOR).

Стоп - что? Первое, что мы сделаем при написании большого кода -
    - пишем тесты, которые хотим пройти(на уже готовые интерфейсы).
