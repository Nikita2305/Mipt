C++ - подготовка к зачёту.

1. 
Почему С++? Низкоуровневый. Популярный. Смежный с другими.
Бьёрн СтраусТруп:)

Комитет стандартизации С++. Версии 98, 03 \/ 11, 14, 17, 20

Linux. Основные команды. Vim.
Компилирование файла С++. Cpp -> Исполняемый файл -> Компилируем его.
g++, clang, msvc.
Флаги компилирования:
	-Wall -Wextra -Werror


2.
CE - то что можно понять на этапе чтения кода
Лексические - разбиваем на токены. А компилятор не смог. Например main(){
Синтаксиеческие - разбил на токены. И не понял что за конструкция int a b; 
Семантические - всё синтаксически верно, но 
	а) Не объявлен x
	б) Неоднозначность
	в) Метод не поддерживается типом

RE - ошибки, происходящие во времени исполнения
	Segfault - обращение к несущ. участку памяти.
		// Ex: Выход за гр. массива, Беск. рекурсия - заполнение всей доступной памяти
	Exceptions

UB - Undefined behaviour
	1) Обращение к несущ. индексу массива, недалеко от правого конца.
	2) Переполнение int

Иногда получаем UB вместо RE, чтобы не подстраховывать и было быстрее.

Unspecified behaviour - поведение, зависящее от реализации:
	int x = f(5) + g(3); // порядок

*Объявление, определение и области видимости.
One definition rule - каждая функция и переменная должна быть ровно один раз определена.
Но объявлена она может быть сколько угодно раз

::x - обращение к глобальной переменной в случае затмения //qualified id. Есть ещё unqualified - без ::
Более локальная - более приоритетная.


3.
С++ - статически типизированный язык - на этапе компиляции у всех известен тип.
Problem of 2039 year - Количество тиков в unix-time станет over int
Операции над char = операции над int
unsigned/signed char - just like [-128..127)

Integer promtion - приведение к большему типу. Напр. int + ll -> ll. int + unsigned -> unsigned!
Управляющие конструкции - if, switch, for, while.


4.
Выражения и опреаторы.
& - побитовое И. && - булевое И.
Префиксный и постфиксный инкремент.
Составное присваивание - без лишних копий. Присваивания - правоассоциативны: (x = y = z) aka (x = (y = z))
sizeof(X) - на этапе компиляции можно посчитать кол-во памяти на стэке. Так что sizeof(x++) не изм. x.
Оператор запятая. x = (expr1, expr2, expr3); Тогда x присвоится return value of expr3. Вычисл. слева направо.
lvalue and rvalue. ++x++ aka ++(x++) - CE, because lvalue required to increment.

Указатели.
int* p = &x; - указатель. Разыминовывание указателя int t = *p; 
p++ or p = 1 + p or p += 1; - сдвиг указателя на sizeof(*p);
int value = p1 - p2; - расстояние между указателями одного типа.
void* - указатель на память, где неизвестно что лежит.
Разыменование nullptr - UB(Segfault). Разыменование полученного указателя - UB(SegFault or expected value).


5.
Виды памяти: автоматическая(стэк), статическая(глобал) - видны в течение всей программы, динамическая(для new)
Программе выделяется сразу [data | text | stack ~ 4mb].
Где data - для статич.(кста static int x в функции например - лежит в data)
stack - для автоматической
delete p - очистка объекта лежащего по указателю p.

Array to pointer conversion.
	int a[5];
	int* p = a;
a[i] = *(a + i)

Difference between int* and int[10]: CE: int b[5] = a; and sizeof(a) = sizeof(int) * 5, but sizeof(p) = 8;
Удаление - delete[] a;

Перегрузка функций.
1) perfect match
2) promotion (int -> long long, float -> double)
3) built-in conversion(char -> int)
4) user-defined conversion(Double -> double)


6.
В случае с f(...) и f(int,int) работает правило Частное Лучше Чем Общее
Указатели на функции.
void (*pg)(int,char) = &g (or frankly = g).

Ссылки. После создания ссылки на объект - это просто другое название данной переменной.
Так что f(int) и  f(int&) - неоднозначный вызов.
С точки зрения памяти - указатель и ссылка хранятся одинаково, как 16чное число.

int& f(int x){ //Локальная переменная уничтожится. Можно сделать static. И она не уничтожится. 
	x++;
	return x;
}

Ссылки нужно сразу инициализировать и нельзя переприсваивать.

Константы. 
const int a = 5;
int* p = &a; - не работает, нужно const int*
p++;
С другой стороны можно int* -> const int*

Константный указатель: int* const p = &a;

Константная ссылка: const int& a = b;
++a; - CE
++b; - OK.

Lifetime expansion. В С++ есть правило
const int& x = 0; - создаёт новый объект, который живёт, пока жива ссылка
Не константные ссылки так не умеют.

7.
Приведение типов. 
int a = 5;
static_cast<double>(var) - создаёт новый объект. Корректность проверяется на этапе компиляции.
reinterpret_cast<double*>(&a) - смотрит на уже существующие объекты под другим углом
reinterpret_cast<double&>(x) 
f(const int& B = a){ int& c = const_cast<int&>(b); - преределает это в неконст } //useless
C-style cast: //Совмещает мощь всех кастов.
const int b = 5;
int& b = (int&)(b);

Классы и структуры. Поля и методы.
Инкапсуляция - принцип, когда поля закрыты от пользователя,функции могут действовать на поля и имеют к ним доступ.
Поля - приватные, согласно инкапсуляции.
В случае перегрузки(private f(int), public f(double), main:f(1): CE) видно, что сначала выбирается перегрузка, затем проверяется доступ. Приватность проверяется в самом конце компиляции.
Можно определять методы вне классов. Когда пишем String::length() - это квалификация имени.
this - указатель на текущий объект. (*this).x = this->x;

Конструкторы и деструкторы.
Определён явный конструктор -> Конструктор по умолчанию не генерируется.
Один деструктор, который вызывается перед уничтожением объекта.
Конструктор по умолчанию = default, запрещение конструктора(как и любой функции) = delete

8.
Rule of three:
Переопределение конструктора копирования String(const String& s) - trivial
Переопределение оператора присваивания copy and swap: String& operator=(String& s) String copy(s); swap(copy); return *this; 
Переопределение деструктора ~String() - trivial
P.S. Все они умеют по дефолту, но в случае нетривиальных типа new char[100]; придётся делать всё.

Делегирующий конструктор: String(...): String(...)
initializer_list 
aggregate initialization(все поля публичны). Point a{1,2};

В случае вызова конструктора - сначала вызываются конструкторы полей. Деструктор - наоборот - в конце.
Мнемоническое правило - читая сверху вниз нормальный код будут так вызываться конструкторы.

Списки инициализации(ака Делегирующий конструктор, но совмещать нельзя).
Поля инициализируются в том порядке, в каком они ОБЪЯВЛЕНЫ, поэтому лучше всё делать в одном порядке.
Иногда это обязательно. Например(constructor) const int x; int& y; A(int a, int& b):x(a),y(b){} 
Продление жизни ссылок - проблема: A(const int& b): y(b){}, main: A a(5) - Rvalue умерло.

Перегрузка арифм. операций.
Copy elision. since c++11. Complex sum = a + b (Не будет лишнего копирования между return value и sum;

Return Value Optimization(RVO) - если создали лок. объект и его вернули в итоге, то он сразу создаётся там, где в main его используем.
Complex operator+(a,b){
	Comlex sum(a);
	a += b;
	return sum;
}

9.
Константные методы.
Константные объекты иногда можно менять, так что это такие объекты к которым применимы только const методы.
Если хотим в const методе менять некоторое поле, то пишем ему mutable.
Олсо, если ссылка в полях, то в случае const объекта получаем int& a -> int& const a -> int& a;
Т.е. ссылка остаётся ссылкой и не становится константной.

Дружественные методы.
Объявляем функцию friend void f(int) - ей можно в private. Точно соблюдаем сигнатуру.
P.S. Можно сначала объявить классы и структуры, а затем определить их методы. | Можно сделать friend класс/метод
Дружба не транзитивна.

Статические поля и методы. - создаются в момент компиляции.
Инициализировать статическое поле (не const) нужно вне класса.
Для конст - целочисл. - можно и внутри. Для double - нельзя.

//Singleton
class C{
	static C* obj;
	C(){}
public:
	static C& getObj();
	~C();
}

Перегрузка приведения типов и Explicit(since c++11).
[explicit] operator int() {return 0} - [явный] оператор приведения к инту.
if(x){...} - не неявный каст к bool. Называется контекстуальная конверсия, может использовать explicit каст к bool.


10.
Перегрузка литерального суффикса. operatror""_D(long double);
Перегрузка круглых скобочек. Объект класса может вести себя как функция. Функциональный класс. Объект - функтор.
Можно передавать функцию в метод. Аналогично можно передавать функтор в метод(например в sort).
Set/map принимает класс, в качестве функции сравнивания. std::greater<int> - сравнение наоборот.
Нельзя создавать новые операторы и поменять приоритет операторов.

Наследование
*Публичное наследование - все знают, что мы наследник.
	паблик -> паблик. Протектед ->протектед.
*Приватное наследование - НИКТО не знает, что мы наследник.
	Паблик + протектед -> приват.
	Работает friend - функционал. Friend не наследуется.
*Протектед наследование - знают только друзья, наследники и их друзья.
	Паблик + протектед -> протектед.

Берётся минимум из уровней приватности короче.
Интересный факт. Даже к протектед полям, принимаемого объекта класса родителя обращаться нельзя.
Даже к приватным полям принимаемого объекта класса себя - можно.
Вторая разница между структурой и классом - наследование по умолчанию публичное и приватное соответсвенно.
В случае коллизии имён(интересно что f(double) затмевает f(string)) при наследовании:
	более локальное затмевает более общее. Ну действительно. Он сначала смотрит на нужное название
	(не сигнатуру) и выбирает список удобных функций. А затем только выбирает из них самое нужное.
Видимость и доступность - сначала проверяется видимость, т.е. выбирается нужная версия функции,
	а затем только проверка доступности(приват, паблик).
	С другой стороны можно написать using Mom::f и f залетит в ту часть куда написали это(напр. в паблик).
	Тогда мы поставим эти функции на один уровень и выберется более удобная из них.
Наследование всех конструкторов: using Mom::Mom;

11.
В целом - о том, как хранится объект класса - наслоение частей всех родителей.
Порядок конструкторов и деструкторов при наследовании - гарантируется, что сначала создается база, а затем сам класс
Уничтожается сначала база. Затем сам объект. Мнемоническое правило работает.
Можно вызывать делигирующий конструктор от базы(непосред). Интересно, что можно совмещать со списками инициализации.
В случае отсуствия делигирующего конструктора от базы - вызывается дефолтный конструктор.

Приведение типов при наследовании.
Очев. const Base& -> Base& - запрещено. CE. А также неявные касты вниз - СЕ.
Однако явные вниз - можно, ака Derived& d = static_cast<Derived&>(b); - UB в случае не Derived.
Reinterpret_cast вместо статика - любой объект к любому может привести, ничего не двигая по памяти.

В случае каста объекта вниз Base b = d. Обрезается лишняя часть Drived d. - Slicing.
Аналогично с указателями.
(Можно запретить касты вверх через private/protected наследование).

Множественное наследование. Son: public Mother, publuc Father
В случае кастов вверх Father* f = &s; оказывается f != &s, потому что сначала лежит часть [mother][father][son]
И при касте отца к сыну, статик каст сдвинет указатель на sizeof(mother) влево.
В случае одинаковых переменных в обоих родителях, и вызове у сына этой переменной - возникает неоднзначность

Проблема ромбовидного наследования.
При вызове son.granny_var - возникает неоднозначность, т.к. son = [g][m][g][f][s], т.е. две копии грэни.
Можно использовать Mother::granny_var, чтобы неоднозн. избежать.
Кастовать вверх son->granny нельзя никаким кастом. Можно только последовательно кастовать.

12.
Виртуальное наследование - решение проблемы ромбовидного наследования.
Пишем Mother: public virtual Granny, Father: public virtual Granny;
В этом случае классы Mother и Father хранятся как [ptr][m] + smth_strange + [g].
Это о том, что часть грэни лежит в памяти отдельно.
Теперь у нас хранится одна версия грэни и каст к ней(как и раньше) сдвигает адрес(Granny& g = s;)
Однако при виртуальном наследовании явные касты вниз отлетают, т.е. static_cast<Son&)(g) - CE

Наследуя вирт + невирт, не получим нерешение проблемы. Аналогично, наследуясь виртуально от мамы и папы - нет.
Приватность проверяется в самом конце и поэтому неоднозначность будет оставаться даже в случае приватного наследования от Father, например.
Пример о прямоугольно-треугольном наследовании(Son:Mother, Granny)

Полиморфизм.
В случае Base::f, Derived::f; main: Base& b = d; b.f() - получим f из Base.
Решение - делаем обе функции виртуальными.
Функция виртуальная - такая что в случае коллизии вызовется версия насл. Выбор версии происходит в рантайме.
На самом деле достаточно сделать виртуальной функцию в Base? Затем у всех наследников она будет виртальной.
Тип считается полиморфным, если есть хотя бы один виртуальный метод. 
При полиморфности важно соблюдать сигнатуру вплоть для константости.(чтобы функции склеивались в одну)
Т.е. когда вызываем метод от Base(виртуальный/не виртуальный): на этапе компиляции выбираем нужную версию для Base.
Затем на этапе рантайма выбирается нужная из виртуальных её переопределений(если она виртуальная).
Очень соблюдаем сигнатуру. Чтобы не залажать стоит писать override (после конст, если есть).
Чтобы запретить переопределение виртуальной функции(даже без оверрайд) - пишем final;

Абстрактные классы и чистые виртуальные функции.
Можно оставить функцию без реализации(чистый виртуальный метод): virtual double area() = 0;
Если есть хотя бы один чистый виртуальный метод, то класс называется абстрактным(Shape)
Чисто виртуальные методы можно определять, чтобы потом писать square.Shape::area();
Объекты типа Shape - как абстрактного класса - создавать нельзя, но можно создавать ссылки и указатели на Shape.

13.
Проблема виртуального конструктора.
Если мы удаляем прикастованный вверх объект, то вызывается верхний деструктор(не вирт). Все остальные - нет. Плохо.
Делаем деструктор виртуальным - тогда в рантайме выбирается нужная версия. Победа.
Делая деструктор чисто виртуальной функцией, можно достигнуть притянутого за уши абстрактного класса.
Также мы получим ошибку линкера, а значит нужно определить деструктор(можно сразу, можно = 0, а потом отдельно)

RTTI - Run-Time Type Information.
Компилятор не может в компайл тайме понимать, что лежит под указателем в общем случае. Пример - Base& bb = (усл?b:d)
Значит это решение принимается в рантайме. И про каждый полиморфный тип нужно поддерживать информацию
о реальном типе той или иной переменной. Напр. Mother& m = s; 

dynamic_cast - принимает решение о касте вниз полиморфного типа в рантайме, смотря на RTTI.
(Upd. Каст вверх работает и для не полиморфных типов.)
Успешность каста вниз зависит от реального типа кастуемой штуки. - RT
Динамик каст вернёт nullptr в случае неуспешного каста указателей.(иначе дропнет исключение)
Динамик каст даёт СЕ, только если кастуемое лежит в разных графах наследования.

Пример, где все касты сделают разное.
Mother* pm = new Son;
static_cast<Father*>(pm) - CE, т.к. не на одной ветке.
dynamic_cast<Father*>(pm) - ОК, т.к. в одном графе и на самом деле pm - указатель на сына
reinterpret_cast<Father*>(pm) - UB, т.к. вообще кринж какой-то.

typeid(m) == typeid(s) - говорит о равенстве классов. Для полиморфных типов работает с RTTI.
еще typeid(m).name() - возвращает что-то похожее на имя класса

Vtables и размещение полиморфных объектов в памяти
Для каждого полимфорфного типа есть vtable, которая хранится в статич. памяти.
Собстна для любого объекта полиморфного типа есть указатель на соотв. vtable.
vtable: [typeinfo_ptr] [virtual_func_1_ptr] ... [virtual_func_n_ptr]
То есть когда мы кастуем полиморфные типы, он оставляет указатель на ту же vtable
и поэтому может понимать какую функцию вызывать для полиморфного типа&.
Все эти прыжки по указателям это долго, поэтому для ускорения по умолчанию в С++ функции не виртуальны.

Шаблоны - делаем обобщённое что-то. Можно думать об этом как о кванторах.
template<int N, int M, typename T> - префикс который можно ставить перед определением
Функций. 
	const T& maximum(const T& a, const T& b) { return a > b ? a : b; }
	Если вызвать maximum(1, 1.0) - CE, т.к. не понятно, к чему приводить - неоднозначность.
		Решение: maximum<int>(1, 1.0)
Псевдонимов.(since C++11)
	template <typename T>
	using mymap = std::map<T,T>
	Вызов: mymap<int>
Переменных. (since C++14)
	template <typename T>
	const T pi = 3.14
	Вызов: pi<int>
Классов и методов классов.
	template<typename T>
	struct vector{
		template<typename U>
		void f(const U& x)....
Синтаксис - typename == class, но better typename

14.
Перегрузка шаблонных функций.
В случае коллизии имён, если есть шаблонная функция и обычная, то
	1) Частное лучше общего
	2) Возможность получения точного соответствия через шаблоны лучше, чем каст
В случае одинаково хороших версий будет СЕ. Например - f(int), f([const] int&) - ambigous.
С другой стороны f(int&), f(const int&) - нужен каст энивэй.

Специализация шаблонов - есть шаблонный класс S, но для некоторого конкретного случая нужна другая реализация.
Тогда полная специализация:
	template<>
	class S<bool> {
	}
Частичная специализация:
	template <typename T>
	class S<*T> {
	}
Частичные специализации бывают:
	для указателей, для ссылок, константных сслылок, для массивов
	по фиксации нек. аргумента, например у дефолта - 2 аргумента(T, U), у обычного - 1(T, T)
Правила с выбором функций сохраняются.

Для функций бывает полная специализация(частичной нет). Аналогично классам.
В случае выбора из перегрузок сначала выбираются шаблонные функции, а затем в выбранной выбир-ся специализ-ия
В этом разница между перегрузкой и специализацией функции.

В любых шаблоных можно делать дефолтные шаблонные аргументы, аналогично функциям.
На самом деле можно делать шаблонными параметрами числа(целочисленные), bool и char.
Создавать шаблоны можно только от тех параметров, которые объявлены, как const int x = 5.
Более того, можно передавать шаблонные параметры, например:
template<typename T, template <typename U> class Container>
template<typename T, template <typename> class Container>
template<typename T, template <typename> class Container = std::vector>
template<typename T, typename Container = std::vector<T>>
Стоит понимать, что template - требует шаблон, например vector, typename - тип, например vector<int>

15. 
Зависимые имена.
Интересный факт, можно придумать пример:
(делаем шаблон, делаем его специализацию для int, в одном делаем X = T, в другом static int X = 0)
(затем шаблонная функция от T, которая обращается к S<T>::X * a;)
С одной стороны это создание указателя, с другой умножение. Компилятор в целом не понимает S<T>::X в общ. случае
Компилятор по умолчанию говорит, что X - число по умол.
Чтобы в случае неоднозначной подстановки и вставлять тип пишем - typename S<T>::X * a;

Другая неоднозначность. SS<T>::A<1,2> a; Неочевидное понимание - знаки меньше и больше.
Решение - пишем: typename SS<T>::template A<1,2>

Короче: typename в начале говорит, чтобы он считывал имя типа, и не ждал шаблон.
template говорит, чтобы он считывал шаблон и не останавливался раньше. Где он - компилятор.

Type Traits. Иногда мы хотим сравнивать типы в шаблонных функциях. Написать T = U, нельзя, но можно вызвать
std::is_same<T, U>::value - в общем случае это метафункция(реализуется как шаблонная структура со специализацией, через static bool value)
std::remove_const<U>::type - так же шаблонная структура со специализацией <const T> со снятием (using type = T)
Ещё немного, алгоритм аналогичный.
std::remove_reference<U>::type, std::remove_pointer<U>::type, std::remove_extent<U>::type,
std::decay<T>::type - убирает все звёздочки и квадратные скобочки.
Начиная с с++14 есть шаблонные псевдонимы для всех этих функций, кроме is_same. Напр. remove_const_t<V>;
Начиная с с++17 есть шаблонные переменные для is_same. Напр. is_same_v<U,V>;

Вариативные шаблоны (с++11). Синтаксис:
print(){} //чтобы запустилось от пустого хвоста
template<typename Head,typename... Args> //здесь многоточие означает, что принимаем пакет типов
void print(const Head& head, const Tail&... tail) {//здесь примерно тоже самое
	std::cout << head << " ";
	print(tail...); //к пакету можно применить распаковку пакета такой операцией.
}
также можно узнавать размер пакета: sizeof...(tail)
Более того, в темплэйте класса, если есть Tail..., то его в специализации можно отбросить.

Оффтоп. Как узнать какой тип скрывается под T в template. Создаём:
template<typename T>
class C {
	C() = delete;
}

А затем:
template <typename T>
void f(T x){ C<T> c; } // CE с указанием типа T.
Так, мы узнали, что
f(int) трактуется как T = int
f(int&) трактуется как T = int
f(const int&) трактуется как T = int
f(const int) трактуется как T = int
P.S. помним, что можно делать специализацию: f<int&>(int&), T = int&

Если же:
template <typename T>
void f(T& x){ C<T> c; }
То f(int) -> T& = int&
f(const int) -> T& = const int&
c int& and const int& - аналогично.

Последний(надеюсь) случай:
void f(const T& x) {C<T> c;}
T = int anyway

Там что-то про референс_враппер - динамические ссылки, ну воппер короче в Маке за полцены. заебало.

