Move - семантика и rvalue - references

Мотивация move-семантики. since С++11: крупное изменение.

1) Рассмотрим push_back(const T& value).
    ... new(arr + sz) T(value) // - конструктор копирования

Т.е. когда пишем vector<string> v;
v.push_back(std::string("abc")) - создаётся временный объект, который скопируется.
    //Т.е. дважды происходит создание объекта

2) Также realloc() вызывает конструрование объектов копирования.
Т.е. наша семантика устроена сейчас так, чтобы создание нового объекта возможно через копирование.
А хочется как-то "переподвесить" "права" на объект в другой массив.

В Java, например, решение - копирование объекта = создание ссылки на тот же.
Но тогда нужен сборщик мусора, который по итогу не даёт выйгрыша во времени.

3) Реализация std::swap
template <typename T>
void swap(T& x, T& y) {
    T tmp = x;
    x = y;
    y = t;
} // Три конструктора копирования, что в нек. моментах - перевыделение ресурсов.

4) Имеем шаблонную функцию
template <typename T>
T createObj(...) {
    //
    return obj;
}

MyHeavyType t = createObj(); // Copy elision произойдёт.
f(createObj()) // Не произойдёт. Тут в функции нужно либо принимать по ссылке(только константной - для врем. обък)
Ну тогда его менять низя. Либо по значению, что означает лишнее копирование.
Ну даже если по значению(тип не изб. копир),
то f(t), where type(t) = HeavyType, произойдёт лишнее копирование уж точно.
Тогда можно создать вторую функцию - одна для временных объектов, другая для неврем.
Одинаковые имена низя, а значит разные - ну это какой-то костыль.
Примером такой функции явл push_back в точности(пример 1).

Решение конкретной проблемы push_back:
template <typename... Args>
void emplace_back(const Args&... args) {
    construct(..., args...); // Т.е. объект создастся на самом последнем этапе на нужном месте.
}

На самом деле, всилу того, что аргументы снова по const ссылке, то имеем аналогичную проблему, только
запихнутую на "уровень выше"

Так вот решением всех проблем является move-семантика.
Сейчас научимся пользоваться функцией move. 
Тип moovable - если к нему применима std::move.
Since c++11 имеем функцию std::move. // Comment - кажется будет не слишком понятно, но это важно.

В случае std::swap(x,y):
T tmp = std::move(x); //O(1)
x = std::move(y)
y = std::move(t)

Т.е. содержимое объекта x в некотором смысле перевозится в объект tmp.
Пример: std::string s = "abcd"
ss = std::move(s)
s.size() = 0

2 заблуждения о move(а скорее правильные ответы): // На прошлом экзе было
1) std::move(ss); // ничего не происходит ваще
2) ss = std::move(s); // Теперь обращение к s остаётся валидным

Наши классы(ранее написанные) не поддерживают move-семантику, т.е. для них tmp = std::move(s) работает за O(n).
В этом случае также обнуление происходить не должно
Чтобы это работало для них - необх. определить в них. нек. функции.
Пока будем говорить о ситуациях с присваиванием / конструктором копирования, а не f(makeObj(..))
Т.к. это несколько другой случай, в котором не всегда можно f(std::move(makeObj(..))) // Ах да, так можно
// И не нужно так вроде


Как же сделать так, чтобы это работало и для наших классов тоже? 
Рассмотрим как это сделать(дописать) на примере String - первое задание 1-сем по ООП.
**Move - конструктор, move - assignment operator, The Rule of Five
The Rule of Five - если для класса копирования определено что-то из The Rule of Three или Move-конструктор или Move - assignment operator, то нужно определить всё!

Определение своего move-конструктора
String(String&& s): sz(s.sz), str(s.str) {// Принимает особую ссылку на String.Пока не знаем, просто адвансд ссылка
    s.str = nullptr;
    sz = 0;
}
// const в аргументах - ни нада, т.к. собираемся обнулять.
// Останется верным через std::swap(..,..), но привед. вариант не инициализирует ничего по умолчанию, а сразу устнв
Move - семантика имеет смысл для сложных типов, но никак не int, например.

Теперь по поводу operator=
String& operator=(String&& s) {
    String new_s = std::move(s)
    swap(new_s)
    return *this;
}
// На паре изменили operator=(String& s) {...} -> operator=(const String& s) { String copy = s;...}
Т.к. Илья не был уверен в том, что перегрузка между двумя операторами = будет разрешена корректно.
// Стоит понимать, что тут есть s, new_s, this - 3 строки и ваще понимать чё тут происходит
// Стоит видеть красивую симметрию между move operator= и copy operator=.

Генерация этих методов по умолчанию. //... = default;
Если реализован хотя бы один конструктор / op=, то прям совсем по умолчанию не генерится второй, 
а что происходит при = default?
Для String(String&& s) = default будет работать неверно, почему?
Конструктор перемещения просто вызывает std::move() от всех полей одного, присваивая другому,
но в случае чисел(или указателей - более наглядно), это неверный подход, т.к. тогда при 
std::move(ptr) - не обнуляет ptr и по итогу имеем два указателя на одну память и это плохо.
Но std::move(shared_ptr) - обнуляет напр. 

Три варианта определить move - констр
1) {...}
2) = default
3) = delete

// Тут ещё раз про почленный move в случае авто-генерации. Подходит для случаев, когда все поля - объекты.
В случае если, например, одно из полей - not movable (= delete или приватные move-методы), то 
move - констр всё равно не сможет быть авто-сгенерирован.
Кажется для operator= правила +- одинаковые.

И так, как же решить проблему с push_back-ом с помощью move. (Помни, что согл. ~75-строке это другой случай)
Сделаем 2 push_back.
1) - by const T&
2)
void push_back(T&& value) {
    if (sz == cap) reserve...
    AllocTraits::construct(alloc, arr + sz, std::move(value));
    ++sz;
}

Однако это не помогает с emplace_back. Т.к. половина аргументов не должна быть мувнута(потёрта), а половина - да.
    // Об этой проблеме в некст лекции. Она тоже про std::move

Аналогично в reserve, например, теперь нужны move.


Теперь давайте узнаем, как это работает и что такое T&&.
Формально определим lvalue и rvalue. - с этими понятиями тесно связано понятие move-семантики.
Первые определения такие
lvalue - можеьт стоять слева от =, rvalue - не может. Справа могут оба)

Пример:
1) lvalue не может стоять справа(const obj)
2) rvalue, который может стоять слева. BitReference в vector bool-ей. Там operator[] возвращает
BitRefernce по знаечнию, а ему присваивается уже значение и т.д.

В С++11 появились xvalue, так что lrvalue перестали даже близко отвечать интуитивным обозначениям.
Миф:
    "Любой объект - это либо rvalue либо lvalue". Так вот понятие lvalue и rvalue существует в рамках контекста.
Т.е. lvalue и rvalue виды выражений(expressions), не объектов и не типов - ВАЖНО.

На этой ноте всё. Ждите след. выпусков.

Прим. лектора.
Наиболее интуитивное(чаще всего так).
lvalue - такое выражение, которое обращение к сущ. объекту
rvalue - выражение, которое создание нового объекта.

Прим. о задаче про Аллокаторы.
FixedAllocators - про создание объектов одного, фикисрованного размера(Например 4,8,16). 
Полезно когда выделяем им память под Nod-ы.
