Продолжение лямбда функций.

Изменение переменных, захваченных из внешности.
Изменение захваченной переменной
[a](){
    a++;
}
- не компилируется.

Можно же:
int a;
const int b;
[a, b]() mutable {
    a++; // Теперь это не CE.
    b++; // Это CE.
}
Сразу все переменные делает изменяемыми.
Но это не влияет на их значения.

Как захватывать по ссылке? А вот как:
[&a, b](int x) {
    a++; // не СЕ, т.к. константная ссылка = ссылка.
    b++; // СЕ
}

Вообще зачем нужны списки захвата? Типа можно же увеличить кол-во параметров на (список захвата).length()
Ответ: в некоторых случаях, например компаратор для sort, требуется ровно 2 или k параметров.


Как лямбда функции устроены внутри(как объекты).

template <typename T>
void g(const T&) = delete;

int main() {
    auto f = [](int x, int y) {
        return x < y;
    }
    g(f);
}
Компилятор вывел: T = main()::<lambda(int, int)>

Если же std::cout << typeid(f).name;
То получим Z4mainEUliiE_
Комприлятор сам придумал тип переменной, так что мы и не должны были увидеть что-то осмысленное.

Если же std::cout << sizeof(f); // 1 байт. Объект без полей.
    Можно считать, что это объект пустого класса с перегруженными пустыми скобочками.

Если же f = [a](int x, int y) {
    return x + a < y;
}

sizeof(f) = 4 байта.

--Полное понимание--:
Создаётся класс у которого полями является то, что мы захватили
И эти поля инициализируются значениями которые мы захватили.
Также есть один метод (типа круглые скобочки - const метод). Именно потому что метод const, 
то мы не можем изменять переменные, захваченные извне.
А значит либо метод стоит сделать mutable, либо хранить ссылку или указатель.


Если f = [a]() {
    a++
    std::cout << a << std::endl;
}
Можно ли auto ff = f;
Да можно. Т.е. есть конструктор копирования.
Если запустить теперь f(), ff();
То дважды увидим 2 2.

Можно ли auto ff = std::move(f);
Да, поля, существующие в f - мувнутся в ff.
Если а - строка, например, то она будет пустой, при последующем вызове f.

Короче все вещи логично следуют из полного понимания.

Оператор присваивания не генерируется для лямбда функций. Ни для каких.

---
auto f = [](int x, int y) {
   return x < y; 
}
Можно ли decltype(f) ff; // так можно делать с++20.
Имеется ввиду - есть ли конструктор по умолчанию? Вот в <=17 - его нет. В С++20 - есть.

Замечание:
int& b = a;
auto f = [b]() mutable { // захватим b, как int a. Так что оно (а) меняться не будет.
    b++;
}


-----
Особенности работы лямбда-функций, когда речь идёт о полях класса.

struct S {
    int a = 1;
    void foo() {
        // auto f = [](int x, int y) { // не сработает
        // auto f = [a](int x, int y) { // не сработает
        auto f = [this](int x, int y) { // сработает - можно захватить копию текущего объекта и всех его переменных = паблик + приват
            std::cout << a; // тут он неявно подставляет this -> a
            return x < y;
        };
    }
}

int main() {
    S s;
    s.foo();
}

Новый пример(когда лямбда функция переживёт объект, который она захватила).

struct S {
    int a = 1;
    void foo() {
        auto f = [this](int x) { 
            std::cout << x + a << std::endl;
        };
        return f;
    }
}

int main() {
    auto f = S().foo();
    auto ff = S().foo();
    f(5); // выведется мусор, т.к. S() уже умерли.
}


Возникает потребность передать значение переменной а, а не указатель на объект.
1) Возможное решение от ученика:
    auto& ref = a;
    auto f = [ref](int x){...}

2) Решение лектора - Capture with initialization and default capture (since C++14)
auto f = [b = a](int x) { // по факту это список инициализации в конструкторе, который будет в классе созданном под эту функцию
    std::cout << x + b << std::endl;
}

Ещё трюк:
auto f = [a = a](int x){...}

Ещё замечание:
auto f = [&a = a](int x){...} // захват не по значению, так что фэйл в "Новый пример 30 строк назад"

-----
Что если хотим мувнуть локальный объект в функцию?
string s = "123";
auto f = [s = std::move(s)](int x) {...}

Аналогично, по этому синтаксису можно захватывать по константной ссылке:
auto f = [&s = std::as_const(s)](int x) {}

Как мы помним можно захватить все локальные переменные по значению.
auto f = [=](int x) {...}  // в том числе, кажется, this будет захвачен.
    // по кодстайлу лучше не надо, т.к. слишком большой захват, и что-то умирает раньше, чем вызывается функция.

Также можно получить всё по ссылкам.
auto f = [&](int x) {...} // аналогично UB, т.к. некоторые объекты умирают.
    // также плохой кодстайл

Более того, можно более гибко:
auto f = (&, s)(int x) {...} // захвати всё по ссылке кроме s
auto f = (=, &s)(int x) {...} // захвати всё по значению кроме s

----
Обобщённые лямбда функции.
auto f = [a](auto x) { 
    std::cout << x + a << std::endl;
}
В этом случае в классе, созданном по f будет шаблонный метод
template <typename T>
void operator()(T x) const {}


---
std::function и его использование. (since c++11)
Это тип, который позволяет инициализировать себя, которые могут быть сallable.
Пример: хотим принимать в качестве компаратора только callable.

Использование:
std::function<bool(int, int)> f; // функция, которая принимает два инта, возвращает буль.
Она может быть проинициализирована чем угодно, в том числе лямбда функция, либо указатель на сишную функцию.
Таким образом можно:
1) f = lambda // пример ниже
2) f = S() // где S - структура с переопределённым operator()
3) f = g // где g - реализованная ранее функция

Пока она не проиницилизирована: f(1,2) бросит исключение std::bad_function_call;

Теперь f = [](int x, int y) {
    std::cout << "Hi\n";
    return x < y;
};

f(1, 2);

Работает ли приведение типов?
Да - Типа можно похожей по сигнатуре функцией проинициализировать.
