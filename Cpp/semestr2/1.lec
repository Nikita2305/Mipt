Exceptions

Idea: функция может завершиться с ошибкой и хочется их обрабатывать
1) Плохой вариант
Передать в функцию указатель/ссылку, которая скажет как завершилась функция и с какой ошибкой.
Почему плохо: код слишком большой, много ветвлений
2) Исключения
Создадим другой способ выхода из функции через throw(это оператор, а значит можно пихать в выражения)
terminate called after throwing an instanse of 'int' - функция 'terminate' вызвана после выброса int
Чтобы ловить наши throw-ы напишем вне функции напишем управляющую конструкцию:
	try{
		f(1, 0)
	}catch(int x){ //also possible ... to catch anything
		cout << "Division by zero!";
	}
Удобность в том, что не нужно никаких переменных для отлова ошибок.

Разница между исключением и рантаймом
Catch-ем можно поймать только то, что было брошено вами!
Однако в Python / Java можно ловить ошибки, которые брошены во время исполнения, типа IndexError
В С++ это упущено для скорости, в основном.
Контрпримеры:
	dynamic_cast бросает исключеение типа std::bad_cast, в случае неудачного каста
	new бросает исключение типа std::bad_alloc в случае невозможности выделения памяти
	std::out_of_range - возникает, если обратиться к вектору методом v.at(i) := v[i]
delete не бросает исключения, т.к. это наша ответственность и мы в силах это проверять сами.
В контрпримерах мы это делать не можем, так что есть такие вот исключения.

std::runtime_error - это не привычные рантаймы, а какой-то подкласс std::exception
Пример:
	...catch(std::exception& ex){
		cout << ex.what();
	}
Можно ещё конструировать так: throw std::exception("message to .what()");

Правила ловли исключений:
1) В кэтче не действуют приведения типов, кроме to-const-conversion or to-parent-conversion и что-нибудь ещё
2) Можно писать несколько catch после try. В таком случае выберется первый подходящий из них
	Также если throw внутри catch, то следующими это не ловится

Исключения и копирование
Чтобы быть броешнным(даже по константной ссылке) объект будет скопирован.
Если копирование запрещено, то бросить не получится
	Кроме случая, когда сконстр. на месте: throw ClassName();
Конструкция throw; - бросает дальше, то что уже поймано(внутри нек. сatch)
	Разница с throw ex; - уничтожит старое исключение и бросит новое, потеряв тип(вдруг мы привели к родителю)

Исключения в конструкторах и RAII idiom
	Если delete вызвать после throw, то по выделенным ресурсам будет утечка!
Пример с конструктором:
struct S{
	int* p = nullptr;
	S(): p(new int(5)) {
		throw 1; // Деструктор не будет вызван. Так что решение проблемы - писать if-ы перед throw.
	}

	~S() {
		delete p;
	}
}
RAII - resourse asquistion is initialization:
template <typename T>
class SmartPtr{
	T* ptr;
	SmartPtr(T* ptr): ptr(ptr) {}
	~SmartPtr(){
		delete ptr;
	}
}
Так что он сам очистит память, перед выходом в throw и всё классно будет.
Однако возникает новая проблема:
	SmartPtr<int> p = new int(5);
	SmartPtr<int> pp = p;
	throw 1; - дважды delete - ПЛОХО(что именно?)
Решение: запретить конструктор копирования в классе SmartPtr.
