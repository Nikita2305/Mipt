Ещё немного про unordered_map.
load_factor - среднее количество элементов в bucket(цепочка).
max_load_factor - то число, при превышении которого таблица rehash-ится
rehash - перехэширование таблицы за линию

bucket_count 
bucket_size(int) 
bucket(key)


Инвалидация итераторов.
Iterator invalidation rules.
Если в векторе произошла переаллокация(после push_back, например), то все ранее сохр. итераторы умрут.
Более того, push_back инвалидирует указатели и ссылки. Аналогично очев и с insert.

Если бы был написан list(двусвяз.), то всё было бы в норме(и итер. и указ.), т.к. нет реаллок.

У deque не портятся указатели и ссылки, но портятся итераторы. (На практике итераторы тоже не инв.)

Почему плохо хранить ссылку на объект(вектор напр.) в итераторе? Потому что это очень много прыжков по указателям
(там чё-т про загрузку в кэш кусков памяти..)

В Map и Set также нет реаллоа, поэтому

В Unordered_map/set по стандарту не ломаются ссылки и указатели.
Что касается итераторов, то после rehash могут сломаться.
Чтобы решить эту проблему, можно восп. reserve, чтобы не было перехэширований.
// Отличие от вектора в том, что в стандарте про него не написано, что realloc не может произойти когда угодно.

Ещё есть std::bitset/array но их опустим.


-----АЛЛОКАТОРЫ-----
Как работает оператор new, ака выделение дин. памяти?

Перегрузка new/delete.
S* p = new S(); = выделение памяти + вызов конструктора.
Тут есть отличие от malloc, которая лишь выделяет память.

В new можно перегрузить только ту часть, которая выделяет память, и вот как.
void* operator new(size_t n) {
    std::cout << n << " bytes allocated\n";
    return malloc(n);
}

Аналогично можно перегрузить delete - принимает указатель. Должен вызывать деструктор,
а затем очищать память.
void operator delete(void* p) {
    std::cout << "dealloc\n";
    free(p);
}

Также можно перегрузить new[] / delete[]

void* operator new[](size_t n) {
    std::cout << "Arr of " << n << " bytes allocated\n";
    return malloc(n);
}

void operator delete(void* p) {
    std::cout << "Array dealloc\n";
    free(p);
}

Если мы перегружаем это всё глобально, а затем, например, инклюднем и используем вектор, то и он будет использовать
наши new и delete, что не круто(наверное).

Что делает стандартная операция new?
Она, как минимум, бросает исключение std::bad_alloc(), если память выделить не удалось. 
    //malloc также возвращает nullptr, если у него не получилось
    Более того, есть функция new_handler, которая перед броском исключения что-то делает и пытается.
    Затем снова пытается произойти выдел. памяти на низком уровне и т.д. (неразборчиво..)
Кстати, напомню, что в С++ не разрешено(как, вроде, в отличии от С), чтобы два объекта имели одинаковый адрес.
    Поэтому если new(0), то выделится 1 энивэй.

В разделении, описанном ранее, есть важная идея.
    Функция operator new и оператор new - разные вещи.
    Функция есть часть оператора, функцию мы переопределяем.
После вызова функции на возвращённый адрес направляются конструкторы.


--Другие формы оператора new/delete.-- 

Можно перегрузить совершенно аналогично в теле класса, для которого хотим перегрузить new/delete.
Будет выбираться более частное.
Интересно, что можно не писать эти методы static, хотя надо бы. Компилятор сам подставит, если вы забудете.

Что интересно, вектор использует new а не new[]. Это некий третий пример, который вскоре поймём.

В main можно написать reinterpret_cast<S*>(operator new(sizeof(S)));
operator delete(p);
Тогда конструкторы/деструкторы вызываться не будут.
// Коммент - в векторе также вызывается operator new(n), а затем сколько надо placement new.

Placement new. Можно направить конструктор на выделенную память.
reinterpret_cast<S*>(operator new(sizeof(S)));
new(p) S();
operator delete(p);

// Коммент - для структуры с определённым внутри new, невозможен placement new.

Т.е. можно переопределить plcnt new.
void* operator new(size_t m, S* p) {
    return p; //этот формализм нужен, но суть не понял.
}

Однако plcmt delete не существует. 

new можно сделать с несколькими параметрами - кастомить короче.
Пример:
void* operator new(size_t n, int x) {
    std::cout << x;
    return malloc(n);
}

x = 5;
new(x) deque<int>; 

--
delete можно в некотором роде тоже, но не совсем.
void operator delete(void* p,..){..free(p)}

operator delete(p, ...)

Данная функция почти никогда не будет вызвана компилятором, КРОМЕ!
Если ты закастомил new и delete одинаковыми параметрами, то при вызове S* s = new(..) S() и броске S() исключения
Что произошло? Выделилась память, запустился конструктор, вылетело исключение, память нада освободить
    Как это делать? - Компилятор сам ищет соответствующую версию опреатора delete и вызывает ваш кастом.

-------
Начало Аллокаторов.
В чём проблема - оперируя с new/delete - работаем с самой низкой частью С++, а зачем?
Решение - аллокаторы(классы), надстройка над new/delete. - Способ переопределить выделение памяти
до того, как вы обратитесь к оператору new.
Например, можно запросить у операционной системы сразу много памяти, используя её затем последовательно
по малым кусочкам. Ведь каждое использование new дост. долгое, как спуск до самой глубинной абстракции.

Аллокатор в конструкторе вызывает единственный new, а затем по требованию выделяет ещё по чуть-чуть.
Способ на более высоком уровне осуществлять работу с памятью.
