Файберы - пример реализации потоков.
Файберы - не параллельны, они исполняются в одном физическом потоке.

Базовая сущность - планировщик, в котором в очереди(run-queue) лежат файберы.
RunScheduler - создаёт его в пространстве пользователя.

С помощью Yield-ов можно переключать на исполнение того или иного файбера.
Сами они не переключаются, в отличие от потоков.

Утверждение про Yield - заходим один раз, выходим дважды (что бы это ни значило).

1) Файберы параллельными по итогу станут
2) Наши файберы не будут вытесняться (хотя можно). Утверждается, что в файберах будут легковесные штуки, так что наших переключений (в блокирующих операциях).

Утверждается, что это один в один потоки(т.е. достаточно изучить файберы).

Под вопросом - как написать Yield.
Отстранённо:
Для того чтобы процессор знал куда возвращаться после рекурсии - стек вызовов. //call и ret туда же
Вызовы разных файберов чередуются, так что нам нужно разобраться с тем, что делать со стеком.


Вопрос - как переулючить исполнение с одной функции на другую.
В каком то смысле - это сохранить нынешние регистры и затем скачать из откуда-то.

cont.SwitchTo(cont1); // ExecutionContext class - tiny fibers

Откуда берутся объекты контекстов? Пока хз, но в общем - руками.

Что такое файбер:
лямбда (корутина)
стэк - у каждого файбера свой стэк вызовов. По факту - сырая память. Создание - через mmap.
контекст - поле заполнено, если файбер остановлен, чтобы потом из контекста загрузиться
стейт - Running/.../...
id - уникальный идентификатор

Пользователь получает доступ лишь к абстракции - joinHandler/Spawn/Yield/...

На самом деле Yield прыгает не сразу в нужный код.
А на код планировщика, исполняющемся на стэке исходного main-а.
У планировщика тоже есть контекст и стэк.

-- Какая-то магия в SwitchTo, которая полностью решает задачу. --

Вернёмся на уровень ExecutionContext.
Calling conventions закрепляет тот факт, что //callee-saved registers// будут сохранены при переключениях. На эти регистры будет полагаться ExecutionContext, только конркетные регистры сохранять.

Будем писать на assembler-е. С rip надо как-то по особенному обращаться.
Сохраняем регистры на текущий стэк(стэк main-а/Scheduler-а в нашем случае)
rip сохраняется автоматически при вызове call, и пиздится с помощью ret нашей функции SwitchTo.

Проблема с первым вызовом файбера - нужно руками подготовить стэк для него.
Проблема с завершением файбера - можно провалиться вне стэка(если не побеспокоиться об этом).
Решение - трамплин - оболочка над вызовом файбера.
Трамплин находится на дне колстека. Terminated флаг.


