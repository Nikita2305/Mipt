Файберы - 2
(Речь вновь о реализации)

Когда мы делаем Yield():
 файбер отдаёт управление планировщику
 планировщик меняет контекст
 отдаёт управление другому файберу (лежат в queue)

Хотим смену контекста вынести из задач планировщика, 
а затем очередь файберов распараллелить

Coroutine. Или сопрограмма.
Отличие от подпрограммы - в том, что можно делать suspend() вместо return
и делать это несколько раз в программе.
Чтобы вернуть управление сопрограмме - resume в main-е.

Как видно - сопрограмма напоминает файберы.
Разница всё таки есть:
	когда мы говорим про файберы - потенциально
	корутины ближе к функциям, не связаны с потоками.
		Также работа с исключениями такая же.
		Никакой конкуренции нет.
Чистая единица concurrency - сопрограмма. Мы будем их использовать для построения файберов, но рассмотрим пример их отдельного использования.

Представим себе итератор на бинарном дереве.
Подумаем какая у него структура.
Это какой-то стек с вершинами(путь), чтобы можно было возвращаться.
Реализация - кринж, поскольку сложно и непонятно.
Лучше - Напишем функцию рекурсивного обхода дерева, в которой будем вызывать callback()

Заметим, что есть идеальная аналогия.
Стейт обхода - стек вызовов.
Стейт итератора - стек вершин.
Стейт корутины - стек вызовов.
Тогда можно выпрямить рекурсию с помощью корутины вызовом Suspend вместо callback.
По мнению лектора - заебок идея, ибо не пришлось думать при написании кода.

Пример:
Принимаем данные по сети(например JSON), хотим их парсить из по дереву.
Можно - получить кусок, Resume парсер. Когда данных в парсере не хватает - Suspend().
И так далее.

Сейчас в С++ используются для разрешения конкуренции, однако были придуманы в 1963 для изоляции стадий компиляции.

Самый сок.
Можно представить Файбер как корутину.
Скомбинируем ThreadPool и Fiber-ы.
Кажется? Планировщик Resume-ит Файбер, тот делает Yield, Плнировщик делает Submit в threadpool и этот файбер вновь когда-нибудь исполнится.

Как устроен Resume и Suspend - это переключение контекста (см Файберы-1). Что-то про трамплин.

—————

Решим проблему коммуникации файберов с внешним миром.
Решение существующее на C - epoll. Мы не хотим этот кринж.
Решение существующее на С++ - asio::io_context.
Какой-то пук-пук про конкретную реализацию async echo server

Асинхронная операция - та, что ждёт совершения операции (например async_accept) - а затем запускает обработчик.

В пук-пуке были построены цепочки неблокирующих действий и всё происходит в одном потоке.
Стека у нас нет, мы же async. А значит данные для каждой сессии будут на куче.
Мы продляем жизнь сессии с помощью make_shared(this) внутри do_read, do_write.
Обработка исключений только через error_code, а не исключения, т.к. исключения используют стек.
// В каком-то смысле - похоже на стейт автомат.

Альтернатива(плохо, т.к. потоков мало) - для каждого клиента свой поток со своим стеком.

Проблема нашего кода с async - он непонятный, исполнение подчиняется логике event loop-а, который скрыт в коде. Хотим писать понятный код (как в Альтернативе), чтобы он работал также как в пук-пуке.

— Пропуск —

Утверждение - можно написать Компилятор, который будет преобразовывать thread-код в async-код с локалки -> поля, функции -> стейты
