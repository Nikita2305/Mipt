Модели памяти (сдвоенная)

Рассуждать о параллельном исполнении кода (в трёх одинак .txt файлах) - наивно.

Но почему: в том числе потому что ячейка памяти может иметь несколько значений одновременно (cache-и, напр.)

Более того:
Рассмотрим простой код
a = b + 1
b = 1

При компиляции записи  на самом деле поменяются местами.

А также процессор иногда ведёт себя неочевидно(назвём crucial):
запись в x = 1
чтение из y

Другой поток:
запись в y = 1
чтение из x

На выходе два нуля. Разберём почему:
Общение по шине кэшей заставляет процессор ждать.
Поэтому придумали оптимизацию Store Buffer.
Если в кэше нет кэш-линии с x, то мы в store buffer кладём x=1.

Назовём это "условным реордерерингом". Хотя на самом деле ничегоособо не меняется местами - каждое ядро исполняет последовательно.

Сценарий называется "Store buffering".
Эта проблема реализуется в сборке мусора и futex-е.
Утв-ся что это единственный печальный случай на нашем intel.

Посмотрим на ARMv8
Оказывается что Buffer-ы могут быть общими для неск. ядер.
Это всё особенности для каждого процессора.

Совершенно не поняно как в таком сложном мире жить.
На что можно в таком мире опереться.

Это приводит нас к моделям памяти. До с++11 многопоточка не могла быть кроссплатформенной.
Определим главные вопросы, на который они отвечают.
- В каком порядке выполняются чтение и записи из разных потоком
- Модель памяти описывает все возможные исполнения многопоточной программы.
- Модель паяти гарантирует, что чтение увидит нужную запись.

Что значит нужную? Пример: спинлок

Где есть MM:
- Первый язык который ввёл memory models: у java.
- Другой пример: язык Go
- Модели в Linux Kernel
- С++
Притом по возрастанию сложности.

Rust утверждает, что в нём нет моделей памяти. Он их просто наследует

Модель памяти С++
Такие сценарии захардкожены 

LLVM ещё
На GPU тоже можно вычислять что-то.
У любого API поэтому должна быть какая-то модель памяти.
Но там всё супер сложно. Пример API - Vulkan.

Go-lang нам говорит: dont be clever - типа не парься.
До тех пор пока мы используем seq_cst (дефольный) в mutex/atomic - можно не вдумываться в моделти памяти.

Подходы к Моделям памяти,
Подход1 - операционный: про то как исполняется
Представляем себе абстрактную машину(идеальную модель), а компилятор гарантирует корректность исполнения гарантий.

У intel-a простая модель и сильные гарантии.
У arm-а модель с деревом, где изменения спускаются вниз к памяти от ядра.
У всех процессоров свои модели - так что рассмотрим Подход2:

Подход2 - декларативный: про гарантии (порядки исполнения), которые точно соблюдаются. Исполнение - граф. Вершины - обращения к памяти. Рёбра - гарантии.

Однако в документации языка не будет ничего про граф - там dont be clever expression в духе процессор гарантирует.

Чтобы совместить seq_cst модель памяти и не последоватлеьный процессор - есть memory barriers: инструкции которые помогут фиксировать порядок.
Упрощённо: Они запрещают отдельные типы реордерингом.
У каждого процессора это свои инструкции.
Скажем, на x86 барьер - это mfence. Фактически он сбрасывает стор буфер в память (в кэши, в протокол когерентности).
Сами разработчики говорят что это сложно.

Главный трейд-оф:
1) Хотим быструю программу (компилятор что-то оптимизирует)
2) Хотим простую семантику seq_consistency.
(хотим расставить минимально barrier-ов)

Решение: мы будем гарантировать seq_consistency только корректно синхронизирвоанным программам. Программа без data-race-ов.
Если компилятор с помощью разработчик получит подсказки - то он сможет разрешить трейдоф.

Главная гарантия: если в программе нет гонок (data-race-free) то она допускает только последовательно согласованные исполнения.
Нестрого data-race -- это два неупорядоченных синхронизацией неатомарных обращения к одной ячейке памяти, среди которых есть запись.

Такая гарантия - есть в стандрате С++.
Соглашение из стандарта:
> Я делаю синхр. код (без дата рейсов)
> Компилятор даёт мне быстрое исполнение и простую семантику.

Оставшееся время мы расскажем как эта модель реализована.
Действующие лица:
Ожидания программиста -> Гарантии видимости через частичные порядки.
Реордеринги/инструкции -> Реализация гарантий через инструкции

Что мы будем делать. Мы формализуем гарантии видимости(для программиста).
Цели гарантий - хотим получить видимость последовательного исполнения. С другой стороны чем меньше стрелок предпорядка мы нарисуем, тем больше свободы мы дадим компилятору и сл-но больше оптимизации.

Сегодня говорим только про memory_order::seq_cst.
Пока ограничиваем модель переменными и простыми инструкциями в нескольких потоках.

Определение конфликта - два обращения к ячейке, где кое-где есть запись. (притом даже из одного потока)

2 типа ячеек:
1) конфл. обращения не упорядочены.
Для таких ячеек создадим анотацию atomic
Вокруг таких ячеек будем расставлять барьеры.
2) конфл. обращения упорядочены

Будет три гарантии.

Гарантия 1:
modification order - существует общий порядок модификации одного атомика. Каждый поток наблюдает некоторую подпоследовательность этого порядка.

Гарантия 2:
message passing - хочется
Пример: spinlock
lock(): while(locked_.exchange(true)){}
unlock(): locked_.store(false);

Формализуем его.
Для этого определим happens before - порядок происхождения событий. Нельзя просто считать время - в распр. системах такого понятия нет. 

1) Если событие a предшествовало событию b в пределах одного узла, то a happens-before b.

2) Если событие a - это отправка сообщения, и событие b - полуение сообщения(в другом узле), то a happens-before b.

3) Замыкаем по транзитивности.

А как переформулировать happens-before в MM? Program order - порядок в тексте программы, а не порядок исполнения. - это порядок в пределах одного узла.

Вторая часть happens-before: store-load.
Отношение synchronizes with: если T' за-load-ил store потока T.

Замечание: happens-before считается в runtimе, условно говоря.

Формализуем: если запись happens-before чтения, то чтение обязано увидеть эту запись.

Таким образом мы пруфнули spinlock:
crit1 [happens-before]
load(false) [happens-before]
exchange(true) [happens-before]
crit2

А что если два события записи happens-before чтения. Но не ясно, кто последний happened.
Гонка - два конфл. обращения не упорядоч. happens-before. (не для атомика).

Ещё раз - happens before не про порядок исполнения, а про некоторый условный порядок.

Гарантия 3.
Интересно, что мы всё ещё не пофиксили нашу crucial ситуацию.
Synchronization order: все обращения ко всем атомикам упорядочены во времени(есть общая история обращений). Это сильная гарантия.
Тогда каждый атомик читает последнюю запись в эту ячейку.

Заключим - гарантии построены для seq_cst.
В совокупности - получаем Execution - граф с дугами.

Фундментальный вопрос: 
Что увидит чтение? Чтение согласовано с sync-order и happens before.

Однако почему мы видим граф? Мы же хотели себе последовательное исполнение? Утв-ся, что с соблюдением гарантий и топологической сортировки вершин мы получим что-то похожее на бамбук.

Окей, а как понять, что у нас нет гонок. Утв-ся, что можно проверить, что нет гонки при всех возможных исполнениях в модели чередования.

Ради чего всё это было. Реордеринги.
Синхронизируя потоки через атомики(напр. спинлок) - внутри "критической секции" процессор будет оптимизировать как угодно, а вот реордерить с atomic.store(finished) уже не сможет. Естественная аналогия с mutex-ами.

Итог:
1) Программист - пишет корр-синхр. программу, синхр. через аннотированные переменные.
2) Компилятор в соотв. с аннотациями рассставляет барьеры
3) Процессор реордерит инструкции, соблюдая границы барьеров.

Weak models.
Модель памяти называется слабой если она допускает не sequentially consistent исполнение.

Гарантии(от сильных к слабым).
seq_cst - sync order + happens before
release + acqire: happens_before + modification order
relaxed: modification order

У этих слабых моделей памяти есть недостаток. Пример: самосбывающиеся пророчества. Конкретно такие программы захардкожены ака запрещены.

Реализация MM: этим занимается компилятор. 
Напутствие. Думать про реордеринги и барьеры сложно и не универсально. Думайте про happens-before. Будь оптипистом и верь, что призойдёт что-то хоршее, а не что-то плохое не произойдёт.






























